{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./src/adler32.ts","webpack:///./src/rawdeflate.ts","webpack:///./src/define/typedarray/hybrid.ts","webpack:///./src/bitstream.ts","webpack:///./src/zip.ts","webpack:///./src/crc32.ts","webpack:///./src/heap.ts","webpack:///./src/huffman.ts","webpack:///./src/rawinflate.ts","webpack:///./src/rawinflate_stream.ts","webpack:///./src/zlibt.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","extendStatics","b","setPrototypeOf","__proto__","Array","__extends","__","this","constructor","gCompressionType","adler32_Alder","Alder","update","adler","array","tlen","s1","s2","len","length","OptimizationParameter","Adler32","USE_TYPEDARRAY","Uint8Array","Uint16Array","Uint32Array","DataView","bitstream_BitStream","BitStream","buffer","bufferPosition","ReverseTable","getReverseTable","index","bitindex","DefaultBlockSize","Error","expandBuffer","oldbuf","il","uint8Buffer","set","arrayBuffer","writeBits","number","reverse","num","current","finish","output","subarray","table","CompressionMethod","OperatingSystem","Flags","rawdeflate_Lz77Match","Lz77Match","backwardDistance","code","getDistanceCode_","dist","toLz77Array","codeArray","pos","LengthCodeTable","rawdeflate_RawDeflate","RawDeflate","input","opt_params","compressionType","CompressionType","DYNAMIC","lazy","op","push","compress","blockArray","position","NONE","slice","makeNocompressBlock","FIXED","makeFixedHuffmanBlock","makeDynamicHuffmanBlock","isFinalBlock","bfinal","btype","nlen","data","stream","lz77","fixedHuffman","hlit","hdist","hclen","litLenLengths","litLenCodes","distLengths","distCodes","treeSymbols","treeLengths","treeCodes","bitlen","hclenOrder","transLengths","getLengths_","freqsLitLen","getCodesFromLengths_","freqsDist","getTreeSymbols_","freqs","codes","dynamicHuffman","dataArray","litLen","literal","apply","FixedHuffmanTable","matchKey","matchList","longestMatch","prevMatch","tmp","windowSize","WindowSize","lz77buf","skipLength","writeMatch","match","offset","ilw","lz77Array","Lz77MinLength","shift","searchLongestMatch_","currentMatch","matchLength","j","matchMax","dl","permatch","Lz77MaxLength","litlenLengths","runLength","nResult","rpt","src","result","limit","nodes","values","codeLength","nSymbols","heap","zlibt_ZlibT","Heap","HUFMAX","pop","reversePackageMerge_","symbols","weight","next","minimumCost","flag","type","currentPosition","excess","half","takePackage","x","lengths","count","startCode","MaxCodeLength","crc32_CRC32","CRC32","calc","single","crc","Table","Table_","heap_Heap","getChild","getParent","parent","swap","huffman_Huffman","Huffman","buildHuffmanTable","size","bitLength","skip","reversed","rtemp","listSize","maxCodeLength","minCodeLength","Number","POSITIVE_INFINITY","rBufferType","zip_Zip","Zip","files","comment","addFile","compressed","crc32","DEFLATE","STORE","deflateWithOption","option","encrypted","setPassword","password","file","op1","op2","op3","endOfCentralDirectorySize","flags","compressionMethod","date","plainSize","filenameLength","extraFieldLength","commentLength","filename","extraField","jl","localFileSize","centralDirectorySize","createEncryptionKey","unshift","encode","Math","random","LocalFileHeaderSignature","FileHeaderSignature","needVersion","MSDOS","ENCRYPT","Date","getMinutes","getSeconds","getHours","getMonth","getDate","getFullYear","CentralDirectorySignature","getByte","updateKeys","keyOrigin","rStatus","rBlockType","rawinflate_RawInflate","RawInflate","bufferType","BufferType","ADAPTIVE","resize","blocks","bufferSize","ZLIB_RAW_INFLATE_BUFFER_SIZE","totalpos","ip","bitsbuf","bitsbuflen","BLOCK","MaxBackwardLength","MaxCopyLength","decompress","parseBlock","concatBufferBlock","concatBufferDynamic","hdr","readBits","parseUncompressedBlock","parseFixedHuffmanBlock","parseDynamicHuffmanBlock","octet","readCodeByTable","codeWithLength","inputLength","codeTable","preCopy","olength","expandBufferBlock","expandBufferAdaptive","fixRatio","decodeHuffmanAdaptive","FixedLiteralLengthTable","FixedDistanceTable","decodeHuffmanBlock","codeLengthsTable","litlenTable","distTable","lengthTable","prev","repeat","codeLengths","Order","litlen","currentLitlenTable","ti","codeDist","lengthCodeTable","lengthExtraTable","LengthExtraTable","distCodeTable","DistCodeTable","distExtraTable","DistExtraTable","opt_param","backward","newSize","maxInflateSize","ratio","addRatio","block","ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE","rawinflate_stream_RawInflateStream","RawInflateStream","opt_buffersize","status","blockLength","sp","Status","INITIALIZED","ip_","bitsbuflen_","bitsbuf_","currentBlockType","BlockType","newInput","stop","BLOCK_HEADER_START","readBlockHeader","BLOCK_HEADER_END","BLOCK_BODY_START","UNCOMPRESSED","readUncompressedBlockHeader","BLOCK_BODY_END","DECODE_BLOCK_START","decodeHuffman","DECODE_BLOCK_END","concatBuffer","save_","restore_","_this","bits","parseDynamicHuffmanBlockImpl","e","ZlibT","_super","RESERVED"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export class Alder {\r\n    public static OptimizationParameter = 1024;\r\n    constructor() {\r\n    \r\n    }\r\n    public static update(adler: number, array: Array<any> | Uint8Array) {\r\n        let s1 = adler & 0xffff;\r\n        let s2 = (adler >>> 16) & 0xffff;\r\n        let len = array.length;\r\n        let tlen;\r\n        let i = 0;\r\n    \r\n        while (len > 0) {\r\n        tlen = len > Alder.OptimizationParameter ?\r\n        Alder.OptimizationParameter : len;\r\n        len -= tlen;\r\n        do {\r\n            s1 += array[i++];\r\n            s2 += s1;\r\n        } while (--tlen);\r\n    \r\n        s1 %= 65521;\r\n        s2 %= 65521;\r\n        }\r\n        return ((s2 << 16) | s1) >>> 0;\r\n    }\r\n}\r\nexport const Adler32 = (array) => {\r\n    return Alder.update(1, array);\r\n}\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\nimport { BitStream } from './bitstream';\r\nimport { ZlibT } from './zlibt';\r\n\r\nenum gCompressionType {\r\n    NONE= 0,\r\n    FIXED= 1,\r\n    DYNAMIC= 2,\r\n    RESERVED= 3\r\n}; \r\nexport class Lz77Match {\r\n    public length: number;\r\n    public backwardDistance: number;\r\n    \r\n    constructor(length: number, backwardDistance: number) {\r\n        this.length = length;\r\n        this.backwardDistance = backwardDistance;\r\n    }\r\n\r\n    static get LengthCodeTable() {\r\n        const code  = (length) => {\r\n            switch (true) {\r\n              case (length === 3): return [257, length - 3, 0]; break;\r\n              case (length === 4): return [258, length - 4, 0]; break;\r\n              case (length === 5): return [259, length - 5, 0]; break;\r\n              case (length === 6): return [260, length - 6, 0]; break;\r\n              case (length === 7): return [261, length - 7, 0]; break;\r\n              case (length === 8): return [262, length - 8, 0]; break;\r\n              case (length === 9): return [263, length - 9, 0]; break;\r\n              case (length === 10): return [264, length - 10, 0]; break;\r\n              case (length <= 12): return [265, length - 11, 1]; break;\r\n              case (length <= 14): return [266, length - 13, 1]; break;\r\n              case (length <= 16): return [267, length - 15, 1]; break;\r\n              case (length <= 18): return [268, length - 17, 1]; break;\r\n              case (length <= 22): return [269, length - 19, 2]; break;\r\n              case (length <= 26): return [270, length - 23, 2]; break;\r\n              case (length <= 30): return [271, length - 27, 2]; break;\r\n              case (length <= 34): return [272, length - 31, 2]; break;\r\n              case (length <= 42): return [273, length - 35, 3]; break;\r\n              case (length <= 50): return [274, length - 43, 3]; break;\r\n              case (length <= 58): return [275, length - 51, 3]; break;\r\n              case (length <= 66): return [276, length - 59, 3]; break;\r\n              case (length <= 82): return [277, length - 67, 4]; break;\r\n              case (length <= 98): return [278, length - 83, 4]; break;\r\n              case (length <= 114): return [279, length - 99, 4]; break;\r\n              case (length <= 130): return [280, length - 115, 4]; break;\r\n              case (length <= 162): return [281, length - 131, 5]; break;\r\n              case (length <= 194): return [282, length - 163, 5]; break;\r\n              case (length <= 226): return [283, length - 195, 5]; break;\r\n              case (length <= 257): return [284, length - 227, 5]; break;\r\n              case (length === 258): return [285, length - 258, 0]; break;\r\n              default: throw 'invalid length: ' + length;\r\n            }\r\n        }\r\n\r\n        let table = [];\r\n        let i = 0;\r\n        let c = [];\r\n\r\n        for (i = 3; i <= 258; i++) {\r\n            c = code(i);\r\n            table[i] = (c[2] << 24) | (c[1] << 16) | c[0];\r\n        }\r\n\r\n        return USE_TYPEDARRAY ? new Uint32Array(table) : table;\r\n    }\r\n    public getDistanceCode_(dist: number) {\r\n        /** @type {!Array.<number>} distance code table. */\r\n        let r;\r\n      \r\n        switch (true) {\r\n          case (dist === 1): r = [0, dist - 1, 0]; break;\r\n          case (dist === 2): r = [1, dist - 2, 0]; break;\r\n          case (dist === 3): r = [2, dist - 3, 0]; break;\r\n          case (dist === 4): r = [3, dist - 4, 0]; break;\r\n          case (dist <= 6): r = [4, dist - 5, 1]; break;\r\n          case (dist <= 8): r = [5, dist - 7, 1]; break;\r\n          case (dist <= 12): r = [6, dist - 9, 2]; break;\r\n          case (dist <= 16): r = [7, dist - 13, 2]; break;\r\n          case (dist <= 24): r = [8, dist - 17, 3]; break;\r\n          case (dist <= 32): r = [9, dist - 25, 3]; break;\r\n          case (dist <= 48): r = [10, dist - 33, 4]; break;\r\n          case (dist <= 64): r = [11, dist - 49, 4]; break;\r\n          case (dist <= 96): r = [12, dist - 65, 5]; break;\r\n          case (dist <= 128): r = [13, dist - 97, 5]; break;\r\n          case (dist <= 192): r = [14, dist - 129, 6]; break;\r\n          case (dist <= 256): r = [15, dist - 193, 6]; break;\r\n          case (dist <= 384): r = [16, dist - 257, 7]; break;\r\n          case (dist <= 512): r = [17, dist - 385, 7]; break;\r\n          case (dist <= 768): r = [18, dist - 513, 8]; break;\r\n          case (dist <= 1024): r = [19, dist - 769, 8]; break;\r\n          case (dist <= 1536): r = [20, dist - 1025, 9]; break;\r\n          case (dist <= 2048): r = [21, dist - 1537, 9]; break;\r\n          case (dist <= 3072): r = [22, dist - 2049, 10]; break;\r\n          case (dist <= 4096): r = [23, dist - 3073, 10]; break;\r\n          case (dist <= 6144): r = [24, dist - 4097, 11]; break;\r\n          case (dist <= 8192): r = [25, dist - 6145, 11]; break;\r\n          case (dist <= 12288): r = [26, dist - 8193, 12]; break;\r\n          case (dist <= 16384): r = [27, dist - 12289, 12]; break;\r\n          case (dist <= 24576): r = [28, dist - 16385, 13]; break;\r\n          case (dist <= 32768): r = [29, dist - 24577, 13]; break;\r\n          default: throw 'invalid distance';\r\n        }\r\n        return r;\r\n    }\r\n    public toLz77Array() {\r\n        /** @type {number} */\r\n        let length = this.length;\r\n        /** @type {number} */\r\n        let dist = this.backwardDistance;\r\n        /** @type {Array} */\r\n        let codeArray = [];\r\n        /** @type {number} */\r\n        let pos = 0;\r\n        /** @type {!Array.<number>} */\r\n        let code;\r\n      \r\n        // length\r\n        code = Lz77Match.LengthCodeTable[length];\r\n        codeArray[pos++] = code & 0xffff;\r\n        codeArray[pos++] = (code >> 16) & 0xff;\r\n        codeArray[pos++] = code >> 24;\r\n      \r\n        // distance\r\n        code = this.getDistanceCode_(dist);\r\n        codeArray[pos++] = code[0];\r\n        codeArray[pos++] = code[1];\r\n        codeArray[pos++] = code[2];\r\n      \r\n        return codeArray;\r\n    };\r\n      \r\n}\r\nexport class RawDeflate {\r\n\r\n    public static CompressionType = gCompressionType; \r\n    public compressionType: gCompressionType;\r\n    public lazy: number;\r\n    public freqsLitLen: Array<any> | Uint32Array;\r\n    public freqsDist: Array<any> | Uint32Array;\r\n    public input: Array<number> | Uint8Array;\r\n    public output: Array<number> | Uint8Array;\r\n    public op: number;\r\n    public length: number;\r\n    public backwardDistance: number;\r\n    \r\n    public static Lz77MaxLength = 258;\r\n\r\n    public static WindowSize = 0x8000;\r\n\r\n    public static MaxCodeLength = 16;\r\n\r\n    public static HUFMAX = 286;\r\n\r\n    public static Lz77MinLength = 3;\r\n    constructor(input: Array<number> | Uint8Array, opt_params: any) {\r\n        this.compressionType = RawDeflate.CompressionType.DYNAMIC;\r\n        this.lazy = 0;\r\n        this.input =\r\n        (USE_TYPEDARRAY && input instanceof Array) ? new Uint8Array(input) : input;\r\n        this.op = 0;\r\n\r\n        // option parameters\r\n        if (opt_params) {\r\n            if (opt_params['lazy']) {\r\n                this.lazy = opt_params['lazy'];\r\n            }\r\n            if (typeof opt_params['compressionType'] === 'number') {\r\n                this.compressionType = opt_params['compressionType'];\r\n            }\r\n            if (opt_params['outputBuffer']) {\r\n                this.output =\r\n                (USE_TYPEDARRAY && opt_params['outputBuffer'] instanceof Array) ?\r\n                new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];\r\n            }\r\n            if (typeof opt_params['outputIndex'] === 'number') {\r\n                this.op = opt_params['outputIndex'];\r\n            }\r\n        }\r\n        if (!this.output) {\r\n            this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(0x8000);\r\n        }\r\n    }\r\n\r\n    public static get FixedHuffmanTable() {\r\n        let table = [], i;\r\n      \r\n        for (i = 0; i < 288; i++) {\r\n          switch (true) {\r\n            case (i <= 143): table.push([i       + 0x030, 8]); break;\r\n            case (i <= 255): table.push([i - 144 + 0x190, 9]); break;\r\n            case (i <= 279): table.push([i - 256 + 0x000, 7]); break;\r\n            case (i <= 287): table.push([i - 280 + 0x0C0, 8]); break;\r\n            default:\r\n              throw 'invalid literal: ' + i;\r\n          }\r\n        }\r\n        return table;\r\n    }\r\n\r\n    public compress() {\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let blockArray;\r\n        /** @type {number} */\r\n        let position;\r\n        /** @type {number} */\r\n        let length;\r\n        let input = this.input;\r\n      \r\n        // compression\r\n        switch (this.compressionType) {\r\n          case RawDeflate.CompressionType.NONE:\r\n            // each 65535-Byte (length header: 16-bit)\r\n            for (position = 0, length = input.length; position < length;) {\r\n              blockArray = USE_TYPEDARRAY ?\r\n                (<Uint8Array>input).subarray(position, position + 0xffff) :\r\n                input.slice(position, position + 0xffff);\r\n              position += blockArray.length;\r\n              this.makeNocompressBlock(blockArray, (position === length));\r\n            }\r\n            break;\r\n          case RawDeflate.CompressionType.FIXED:\r\n            this.output = this.makeFixedHuffmanBlock(input, true);\r\n            this.op = this.output.length;\r\n            break;\r\n          case RawDeflate.CompressionType.DYNAMIC:\r\n            this.output = this.makeDynamicHuffmanBlock(input, true);\r\n            this.op = this.output.length;\r\n            break;\r\n          default:\r\n            throw 'invalid compression type';\r\n        }\r\n        return this.output;\r\n    }\r\n\r\n    public makeNocompressBlock(blockArray: Array<number> | Uint8Array, isFinalBlock: boolean) {\r\n        /** @type {number} */\r\n        let bfinal;\r\n        /** @type {Zlib.RawDeflate.CompressionType} */\r\n        let btype;\r\n        /** @type {number} */\r\n        let len;\r\n        /** @type {number} */\r\n        let nlen;\r\n        /** @type {number} */\r\n        let i;\r\n        /** @type {number} */\r\n        let il;\r\n\r\n        let output = this.output;\r\n        let op = this.op;\r\n\r\n        // expand buffer\r\n        if (USE_TYPEDARRAY) {\r\n            output = new Uint8Array((<Uint8Array>this.output).buffer);\r\n            while (output.length <= op + blockArray.length + 5) {\r\n            output = new Uint8Array(output.length << 1);\r\n            }\r\n            output.set(this.output);\r\n        }\r\n\r\n        // header\r\n        bfinal = isFinalBlock ? 1 : 0;\r\n        btype = RawDeflate.CompressionType.NONE;\r\n        output[op++] = (bfinal) | (btype << 1);\r\n\r\n        // length\r\n        len = blockArray.length;\r\n        nlen = (~len + 0x10000) & 0xffff;\r\n        output[op++] =          len & 0xff;\r\n        output[op++] =  (len >>> 8) & 0xff;\r\n        output[op++] =         nlen & 0xff;\r\n        output[op++] = (nlen >>> 8) & 0xff;\r\n\r\n        // copy buffer\r\n        if (USE_TYPEDARRAY) {\r\n            (<Uint8Array>output).set(blockArray, op);\r\n            op += blockArray.length;\r\n            output = (<Uint8Array>output).subarray(0, op);\r\n        } else {\r\n            for (i = 0, il = blockArray.length; i < il; ++i) {\r\n            output[op++] = blockArray[i];\r\n            }\r\n            (<Array<number>>output).length = op;\r\n        }\r\n\r\n        this.op = op;\r\n        this.output = output;\r\n\r\n        return output;\r\n    }\r\n\r\n    public makeFixedHuffmanBlock(blockArray: Array<number> | Uint8Array, isFinalBlock: boolean) {\r\n        /** @type {Zlib.BitStream} */\r\n        let stream = new BitStream(USE_TYPEDARRAY ?\r\n            new Uint8Array((<Uint8Array>this.output).buffer) : this.output, this.op);\r\n        /** @type {number} */\r\n        let bfinal;\r\n        /** @type {Zlib.RawDeflate.CompressionType} */\r\n        let btype;\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let data;\r\n\r\n        // header\r\n        bfinal = isFinalBlock ? 1 : 0;\r\n        btype = RawDeflate.CompressionType.FIXED;\r\n\r\n        stream.writeBits(bfinal, 1, true);\r\n        stream.writeBits(btype, 2, true);\r\n\r\n        data = this.lz77(blockArray);\r\n        this.fixedHuffman(data, stream);\r\n\r\n        return stream.finish();\r\n    }\r\n\r\n    public makeDynamicHuffmanBlock(blockArray: Array<number> | Uint8Array, isFinalBlock: boolean) {\r\n        /** @type {Zlib.BitStream} */\r\n        let stream = new BitStream(USE_TYPEDARRAY ?\r\n            new Uint8Array((<Uint8Array>this.output).buffer) : this.output, this.op);\r\n        /** @type {number} */\r\n        let bfinal;\r\n        /** @type {Zlib.RawDeflate.CompressionType} */\r\n        let btype;\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let data;\r\n        /** @type {number} */\r\n        let hlit;\r\n        /** @type {number} */\r\n        let hdist;\r\n        /** @type {number} */\r\n        let hclen;\r\n        /** @const @type {Array.<number>} */\r\n        let hclenOrder =\r\n                [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let litLenLengths;\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let litLenCodes;\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let distLengths;\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let distCodes;\r\n        /** @type {{\r\n         *   codes: !(Array.<number>|Uint32Array),\r\n         *   freqs: !(Array.<number>|Uint8Array)\r\n         * }} */\r\n        let treeSymbols;\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let treeLengths;\r\n        /** @type {Array} */\r\n        let transLengths = new Array(19);\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let treeCodes;\r\n        /** @type {number} */\r\n        let code;\r\n        /** @type {number} */\r\n        let bitlen;\r\n        /** @type {number} */\r\n        let i;\r\n        /** @type {number} */\r\n        let il;\r\n\r\n        // header\r\n        bfinal = isFinalBlock ? 1 : 0;\r\n        btype = RawDeflate.CompressionType.DYNAMIC;\r\n\r\n        stream.writeBits(bfinal, 1, true);\r\n        stream.writeBits(btype, 2, true);\r\n\r\n        data = this.lz77(blockArray);\r\n\r\n        litLenLengths = this.getLengths_(this.freqsLitLen, 15);\r\n        litLenCodes = this.getCodesFromLengths_(litLenLengths);\r\n        distLengths = this.getLengths_(this.freqsDist, 7);\r\n        distCodes = this.getCodesFromLengths_(distLengths);\r\n\r\n        for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}\r\n        for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {}\r\n\r\n        // HCLEN\r\n        treeSymbols =\r\n            this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);\r\n        treeLengths = this.getLengths_(treeSymbols.freqs, 7);\r\n        for (i = 0; i < 19; i++) {\r\n            transLengths[i] = treeLengths[hclenOrder[i]];\r\n        }\r\n        for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}\r\n\r\n        treeCodes = this.getCodesFromLengths_(treeLengths);\r\n\r\n        // \r\n        stream.writeBits(hlit - 257, 5, true);\r\n        stream.writeBits(hdist - 1, 5, true);\r\n        stream.writeBits(hclen - 4, 4, true);\r\n        for (i = 0; i < hclen; i++) {\r\n            stream.writeBits(transLengths[i], 3, true);\r\n        }\r\n\r\n        // \r\n        for (i = 0, il = treeSymbols.codes.length; i < il; i++) {\r\n            code = treeSymbols.codes[i];\r\n\r\n            stream.writeBits(treeCodes[code], treeLengths[code], true);\r\n\r\n            // extra bits\r\n            if (code >= 16) {\r\n            i++;\r\n            switch (code) {\r\n                case 16: bitlen = 2; break;\r\n                case 17: bitlen = 3; break;\r\n                case 18: bitlen = 7; break;\r\n                default:\r\n                throw 'invalid code: ' + code;\r\n            }\r\n\r\n            stream.writeBits(treeSymbols.codes[i], bitlen, true);\r\n            }\r\n        }\r\n\r\n        this.dynamicHuffman(\r\n            data,\r\n            [litLenCodes, litLenLengths],\r\n            [distCodes, distLengths],\r\n            stream\r\n        );\r\n\r\n        return stream.finish();\r\n    };\r\n\r\n    public dynamicHuffman(dataArray: Array<number>|Uint16Array, litLen: any[], dist: any[], stream: any) {\r\n        /** @type {number} */\r\n        let index;\r\n        /** @type {number} */\r\n        let length;\r\n        /** @type {number} */\r\n        let literal;\r\n        /** @type {number} */\r\n        let code;\r\n        /** @type {number} */\r\n        let litLenCodes;\r\n        /** @type {number} */\r\n        let litLenLengths;\r\n        /** @type {number} */\r\n        let distCodes;\r\n        /** @type {number} */\r\n        let distLengths;\r\n\r\n        litLenCodes = litLen[0];\r\n        litLenLengths = litLen[1];\r\n        distCodes = dist[0];\r\n        distLengths = dist[1];\r\n\r\n        //  BitStream \r\n        for (index = 0, length = dataArray.length; index < length; ++index) {\r\n            literal = dataArray[index];\r\n\r\n            // literal or length\r\n            stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);\r\n\r\n            // \r\n            if (literal > 256) {\r\n            // length extra\r\n            stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n            // distance\r\n            code = dataArray[++index];\r\n            stream.writeBits(distCodes[code], distLengths[code], true);\r\n            // distance extra\r\n            stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n            // \r\n            } else if (literal === 256) {\r\n            break;\r\n            }\r\n        }\r\n\r\n        return stream;\r\n    }\r\n\r\n    public fixedHuffman(dataArray: Array<number> | Uint16Array, stream: BitStream) {\r\n        /** @type {number} */\r\n        let index;\r\n        /** @type {number} */\r\n        let length;\r\n        /** @type {number} */\r\n        let literal;\r\n      \r\n        //  BitStream \r\n        for (index = 0, length = dataArray.length; index < length; index++) {\r\n          literal = dataArray[index];\r\n      \r\n          BitStream.prototype.writeBits.apply(\r\n              stream, RawDeflate.FixedHuffmanTable[literal]\r\n        )\r\n          // \r\n          if (literal > 0x100) {\r\n            // length extra\r\n            stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n            // distance\r\n            stream.writeBits(dataArray[++index], 5);\r\n            // distance extra\r\n            stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n          // \r\n          } else if (literal === 0x100) {\r\n            break;\r\n          }\r\n        }\r\n        return stream;\r\n    }\r\n    public lz77(dataArray: Array<number>|Uint8Array) {\r\n        /** @type {number} input position */\r\n        let position;\r\n        /** @type {number} input length */\r\n        let length;\r\n        /** @type {number} loop counter */\r\n        let i;\r\n        /** @type {number} loop limiter */\r\n        let il;\r\n        /** @type {number} chained-hash-table key */\r\n        let matchKey;\r\n        /** @type {Object.<number, Array.<number>>} chained-hash-table */\r\n        let table = {};\r\n        /** @const @type {number} */\r\n        let windowSize = RawDeflate.WindowSize;\r\n        /** @type {Array.<number>} match list */\r\n        let matchList;\r\n        /** @type {Zlib.RawDeflate.Lz77Match} longest match */\r\n        let longestMatch;\r\n        /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */\r\n        let prevMatch;\r\n        /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */\r\n        let lz77buf = USE_TYPEDARRAY ?\r\n          new Uint16Array(dataArray.length * 2) : [];\r\n        /** @type {number} lz77 output buffer pointer */\r\n        let pos = 0;\r\n        /** @type {number} lz77 skip length */\r\n        let skipLength = 0;\r\n        /** @type {!(Array.<number>|Uint32Array)} */\r\n        let freqsLitLen = new (USE_TYPEDARRAY ? Uint32Array : Array )(286);\r\n        /** @type {!(Array.<number>|Uint32Array)} */\r\n        let freqsDist = new (USE_TYPEDARRAY ? Uint32Array : Array) (30);\r\n        /** @type {number} */\r\n        let lazy = this.lazy;\r\n        /** @type {*} temporary letiable */\r\n        let tmp;\r\n      \r\n        // \r\n        if (!USE_TYPEDARRAY) {\r\n          for (i = 0; i <= 285;) { freqsLitLen[i++] = 0; }\r\n          for (i = 0; i <= 29;) { freqsDist[i++] = 0; }\r\n        }\r\n        freqsLitLen[256] = 1; // EOB  1\r\n      \r\n        /**\r\n         * \r\n         * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.\r\n         * @param {!number} offset ().\r\n         * @private\r\n         */\r\n        const writeMatch = (match: Lz77Match, offset: number) => {\r\n            let lz77Array = match.toLz77Array();\r\n            /** @type {number} */\r\n            let iw = 0;\r\n            /** @type {number} */\r\n            let ilw = 0;\r\n        \r\n            for (iw = 0, ilw = lz77Array.length; iw < ilw; ++i) {\r\n                lz77buf[pos++] = lz77Array[i];\r\n            }\r\n            freqsLitLen[lz77Array[0]]++;\r\n            freqsDist[lz77Array[3]]++;\r\n            skipLength = match.length + offset - 1;\r\n            prevMatch = null;\r\n        }\r\n      \r\n        // LZ77 \r\n        for (position = 0, length = dataArray.length; position < length; ++position) {\r\n          // \r\n          for (matchKey = 0, i = 0, il = RawDeflate.Lz77MinLength; i < il; ++i) {\r\n            if (position + i === length) {\r\n              break;\r\n            }\r\n            matchKey = (matchKey << 8) | dataArray[position + i];\r\n          }\r\n      \r\n          // \r\n          if (table[matchKey] === void 0) { table[matchKey] = []; }\r\n          matchList = table[matchKey];\r\n      \r\n          // skip\r\n          if (skipLength-- > 0) {\r\n            matchList.push(position);\r\n            continue;\r\n          }\r\n      \r\n          //  ()\r\n          while (matchList.length > 0 && position - matchList[0] > windowSize) {\r\n            matchList.shift();\r\n          }\r\n      \r\n          // \r\n          if (position + RawDeflate.Lz77MinLength >= length) {\r\n            if (prevMatch) {\r\n              writeMatch(prevMatch, -1);\r\n            }\r\n      \r\n            for (i = 0, il = length - position; i < il; ++i) {\r\n              tmp = dataArray[position + i];\r\n              lz77buf[pos++] = tmp;\r\n              ++freqsLitLen[tmp];\r\n            }\r\n            break;\r\n          }\r\n      \r\n          // \r\n          if (matchList.length > 0) {\r\n            longestMatch = this.searchLongestMatch_(dataArray, position, matchList);\r\n      \r\n            if (prevMatch) {\r\n              // \r\n              if (prevMatch.length < longestMatch.length) {\r\n                // write previous literal\r\n                tmp = dataArray[position - 1];\r\n                lz77buf[pos++] = tmp;\r\n                ++freqsLitLen[tmp];\r\n      \r\n                // write current match\r\n                writeMatch(longestMatch, 0);\r\n              } else {\r\n                // write previous match\r\n                writeMatch(prevMatch, -1);\r\n              }\r\n            } else if (longestMatch.length < lazy) {\r\n              prevMatch = longestMatch;\r\n            } else {\r\n              writeMatch(longestMatch, 0);\r\n            }\r\n          // \r\n          } else if (prevMatch) {\r\n            writeMatch(prevMatch, -1);\r\n          } else {\r\n            tmp = dataArray[position];\r\n            lz77buf[pos++] = tmp;\r\n            ++freqsLitLen[tmp];\r\n          }\r\n      \r\n          matchList.push(position); // \r\n        }\r\n      \r\n        // \r\n        lz77buf[pos++] = 256;\r\n        freqsLitLen[256]++;\r\n        this.freqsLitLen = freqsLitLen;\r\n        this.freqsDist = freqsDist;\r\n      \r\n        return /** @type {!(Uint16Array|Array.<number>)} */ (\r\n          USE_TYPEDARRAY ?  (<Uint16Array>lz77buf).subarray(0, pos) : lz77buf\r\n        );\r\n    }\r\n    \r\n    public searchLongestMatch_(data: any, position: number, matchList: Array<number>) {\r\n        let match,\r\n            currentMatch,\r\n            matchMax = 0, matchLength,\r\n            i, j, l, dl = data.length;\r\n\r\n        //  1 \r\n        permatch:\r\n        for (i = 0, l = matchList.length; i < l; i++) {\r\n            match = matchList[l - i - 1];\r\n            matchLength = RawDeflate.Lz77MinLength;\r\n\r\n            // \r\n            if (matchMax > RawDeflate.Lz77MinLength) {\r\n            for (j = matchMax; j > RawDeflate.Lz77MinLength; j--) {\r\n                if (data[match + j - 1] !== data[position + j - 1]) {\r\n                continue permatch;\r\n                }\r\n            }\r\n            matchLength = matchMax;\r\n            }\r\n\r\n            // \r\n            while (matchLength < RawDeflate.Lz77MaxLength &&\r\n                position + matchLength < dl &&\r\n                data[match + matchLength] === data[position + matchLength]) {\r\n            ++matchLength;\r\n            }\r\n\r\n            // \r\n            if (matchLength > matchMax) {\r\n            currentMatch = match;\r\n            matchMax = matchLength;\r\n            }\r\n\r\n            // \r\n            if (matchLength === RawDeflate.Lz77MaxLength) {\r\n            break;\r\n            }\r\n        }\r\n        return new Lz77Match(matchMax, position - currentMatch);\r\n    }\r\n\r\n    public getTreeSymbols_(hlit: number, \r\n        litlenLengths: Array<number> | Uint8Array,\r\n        hdist: number,\r\n        distLengths: Array<number> | Uint8Array) {\r\n        \r\n        let src = new (USE_TYPEDARRAY ? Uint32Array : Array)(hlit + hdist),\r\n        i, j, runLength, l,\r\n        result = new (USE_TYPEDARRAY ? Uint32Array : Array)(286 + 30),\r\n        nResult,\r\n        rpt,\r\n        freqs = new (USE_TYPEDARRAY ? Uint8Array : Array)(19);\r\n\r\n        j = 0;\r\n        for (i = 0; i < hlit; i++) {\r\n            src[j++] = litlenLengths[i];\r\n        }\r\n        for (i = 0; i < hdist; i++) {\r\n            src[j++] = distLengths[i];\r\n        }\r\n\r\n        if (!USE_TYPEDARRAY) {\r\n            for (i = 0, l = freqs.length; i < l; ++i) {\r\n            freqs[i] = 0;\r\n            }\r\n        }\r\n\r\n        nResult = 0;\r\n        for (i = 0, l = src.length; i < l; i += j) {\r\n            for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}\r\n\r\n            runLength = j;\r\n\r\n            if (src[i] === 0) {\r\n            if (runLength < 3) {\r\n                while (runLength-- > 0) {\r\n                result[nResult++] = 0;\r\n                freqs[0]++;\r\n                }\r\n            } else {\r\n                while (runLength > 0) {\r\n                rpt = (runLength < 138 ? runLength : 138);\r\n\r\n                if (rpt > runLength - 3 && rpt < runLength) {\r\n                    rpt = runLength - 3;\r\n                }\r\n\r\n                if (rpt <= 10) {\r\n                    result[nResult++] = 17;\r\n                    result[nResult++] = rpt - 3;\r\n                    freqs[17]++;\r\n                } else {\r\n                    result[nResult++] = 18;\r\n                    result[nResult++] = rpt - 11;\r\n                    freqs[18]++;\r\n                }\r\n\r\n                runLength -= rpt;\r\n                }\r\n            }\r\n            } else {\r\n            result[nResult++] = src[i];\r\n            freqs[src[i]]++;\r\n            runLength--;\r\n\r\n                if (runLength < 3) {\r\n                    while (runLength-- > 0) {\r\n                    result[nResult++] = src[i];\r\n                    freqs[src[i]]++;\r\n                    }\r\n                } else {\r\n                    while (runLength > 0) {\r\n                    rpt = (runLength < 6 ? runLength : 6);\r\n\r\n                    if (rpt > runLength - 3 && rpt < runLength) {\r\n                        rpt = runLength - 3;\r\n                    }\r\n\r\n                    result[nResult++] = 16;\r\n                    result[nResult++] = rpt - 3;\r\n                    freqs[16]++;\r\n\r\n                    runLength -= rpt;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            codes:\r\n            USE_TYPEDARRAY ? (<Uint32Array>result).subarray(0, nResult) : result.slice(0, nResult),\r\n            freqs: freqs\r\n        };\r\n    }\r\n    public getLengths_(freqs: Array<number>|Uint8Array|Uint32Array, limit: number) {\r\n        /** @type {number} */\r\n        let nSymbols = freqs.length;\r\n        /** @type {Zlib.Heap} */\r\n        let heap = new ZlibT.Heap(2 * ZlibT.RawDeflate.HUFMAX);\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let length = new (USE_TYPEDARRAY ? Uint8Array : Array)(nSymbols);\r\n        /** @type {Array} */\r\n        let nodes;\r\n        /** @type {!(Array.<number>|Uint32Array)} */\r\n        let values;\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let codeLength;\r\n        /** @type {number} */\r\n        let i;\r\n        /** @type {number} */\r\n        let il;\r\n      \r\n        // \r\n        if (!USE_TYPEDARRAY) {\r\n          for (i = 0; i < nSymbols; i++) {\r\n            length[i] = 0;\r\n          }\r\n        }\r\n      \r\n        // \r\n        for (i = 0; i < nSymbols; ++i) {\r\n          if (freqs[i] > 0) {\r\n            heap.push(i, freqs[i]);\r\n          }\r\n        }\r\n        nodes = new Array(heap.length / 2);\r\n        values = new (USE_TYPEDARRAY ? Uint32Array : Array)(heap.length / 2);\r\n      \r\n        //  0  1 \r\n        if (nodes.length === 1) {\r\n          length[heap.pop().index] = 1;\r\n          return length;\r\n        }\r\n      \r\n        // Reverse Package Merge Algorithm  Canonical Huffman Code \r\n        for (i = 0, il = heap.length / 2; i < il; ++i) {\r\n          nodes[i] = heap.pop();\r\n          values[i] = nodes[i].value;\r\n        }\r\n        codeLength = this.reversePackageMerge_(values, values.length, limit);\r\n      \r\n        for (i = 0, il = nodes.length; i < il; ++i) {\r\n          length[nodes[i].index] = codeLength[i];\r\n        }\r\n      \r\n        return length;\r\n    }\r\n\r\n    public reversePackageMerge_(freqs: Array<number>|Uint32Array, symbols: number, limit: number) {\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let minimumCost = new (USE_TYPEDARRAY ? Uint16Array : Array)(limit);\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let flag = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let codeLength = new (USE_TYPEDARRAY ? Uint8Array : Array)(symbols);\r\n        /** @type {Array} */\r\n        let value = new Array(limit);\r\n        /** @type {Array} */\r\n        let type  = new Array(limit);\r\n        /** @type {Array.<number>} */\r\n        let currentPosition = new Array(limit);\r\n        /** @type {number} */\r\n        let excess = (1 << limit) - symbols;\r\n        /** @type {number} */\r\n        let half = (1 << (limit - 1));\r\n        /** @type {number} */\r\n        let i;\r\n        /** @type {number} */\r\n        let j;\r\n        /** @type {number} */\r\n        let t;\r\n        /** @type {number} */\r\n        let weight;\r\n        /** @type {number} */\r\n        let next;\r\n      \r\n        /**\r\n         * @param {number} j\r\n         */\r\n        const takePackage = ( index: number) => {\r\n          /** @type {number} */\r\n          let x = type[index][currentPosition[index]];\r\n      \r\n          if (x === symbols) {\r\n            takePackage(index+1);\r\n            takePackage(index+1);\r\n          } else {\r\n            --codeLength[x];\r\n          }\r\n      \r\n          ++currentPosition[index];\r\n        }\r\n      \r\n        minimumCost[limit-1] = symbols;\r\n      \r\n        for (j = 0; j < limit; ++j) {\r\n          if (excess < half) {\r\n            flag[j] = 0;\r\n          } else {\r\n            flag[j] = 1;\r\n            excess -= half;\r\n          }\r\n          excess <<= 1;\r\n          minimumCost[limit-2-j] = (minimumCost[limit-1-j] / 2 | 0) + symbols;\r\n        }\r\n        minimumCost[0] = flag[0];\r\n      \r\n        value[0] = new Array(minimumCost[0]);\r\n        type[0]  = new Array(minimumCost[0]);\r\n        for (j = 1; j < limit; ++j) {\r\n          if (minimumCost[j] > 2 * minimumCost[j-1] + flag[j]) {\r\n            minimumCost[j] = 2 * minimumCost[j-1] + flag[j];\r\n          }\r\n          value[j] = new Array(minimumCost[j]);\r\n          type[j]  = new Array(minimumCost[j]);\r\n        }\r\n      \r\n        for (i = 0; i < symbols; ++i) {\r\n          codeLength[i] = limit;\r\n        }\r\n      \r\n        for (t = 0; t < minimumCost[limit-1]; ++t) {\r\n          value[limit-1][t] = freqs[t];\r\n          type[limit-1][t]  = t;\r\n        }\r\n      \r\n        for (i = 0; i < limit; ++i) {\r\n          currentPosition[i] = 0;\r\n        }\r\n        if (flag[limit-1] === 1) {\r\n          --codeLength[0];\r\n          ++currentPosition[limit-1];\r\n        }\r\n      \r\n        for (j = limit-2; j >= 0; --j) {\r\n          i = 0;\r\n          weight = 0;\r\n          next = currentPosition[j+1];\r\n      \r\n          for (t = 0; t < minimumCost[j]; t++) {\r\n            weight = value[j+1][next] + value[j+1][next+1];\r\n      \r\n            if (weight > freqs[i]) {\r\n              value[j][t] = weight;\r\n              type[j][t] = symbols;\r\n              next += 2;\r\n            } else {\r\n              value[j][t] = freqs[i];\r\n              type[j][t] = i;\r\n              ++i;\r\n            }\r\n          }\r\n      \r\n          currentPosition[j] = 0;\r\n          if (flag[j] === 1) {\r\n            takePackage(j);\r\n          }\r\n        }\r\n      \r\n        return codeLength;\r\n    };\r\n    public getCodesFromLengths_(lengths: Uint16Array | Array<number>) {\r\n        let codes = new (USE_TYPEDARRAY ? Uint16Array : Array)(lengths.length),\r\n            count = [],\r\n            startCode = [],\r\n            code = 0, i, il, j, m;\r\n      \r\n        // Count the codes of each length.\r\n        for (i = 0, il = lengths.length; i < il; i++) {\r\n          count[lengths[i]] = (count[lengths[i]] | 0) + 1;\r\n        }\r\n      \r\n        // Determine the starting code for each length block.\r\n        for (i = 1, il = RawDeflate.MaxCodeLength; i <= il; i++) {\r\n          startCode[i] = code;\r\n          code += count[i] | 0;\r\n          code <<= 1;\r\n        }\r\n      \r\n        // Determine the code for each symbol. Mirrored, of course.\r\n        for (i = 0, il = lengths.length; i < il; i++) {\r\n          code = startCode[lengths[i]];\r\n          startCode[lengths[i]] += 1;\r\n          codes[i] = 0;\r\n      \r\n          for (j = 0, m = lengths[i]; j < m; j++) {\r\n            codes[i] = (codes[i] << 1) | (code & 1);\r\n            code >>>= 1;\r\n          }\r\n        }\r\n      \r\n        return codes;\r\n      };\r\n}\r\n","export const USE_TYPEDARRAY =\r\n  (typeof Uint8Array !== 'undefined') &&\r\n  (typeof Uint16Array !== 'undefined') &&\r\n  (typeof Uint32Array !== 'undefined') &&\r\n  (typeof DataView !== 'undefined');\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\n\r\nexport class BitStream {\r\n    public static DefaultBlockSize = 0x8000;\r\n    public index: number;\r\n    public bitindex: number;\r\n    public buffer: any;\r\n    public static ReverseTable: Uint8Array | any[];\r\n\r\n    constructor(buffer: Uint8Array | Array<any>, bufferPosition: number) {\r\n        BitStream.ReverseTable = this.getReverseTable();\r\n        this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;\r\n        this.bitindex = 0;\r\n        this.buffer = buffer instanceof (USE_TYPEDARRAY ? Uint8Array : Array) ?\r\n          buffer :\r\n          new (USE_TYPEDARRAY ? Uint8Array : Array)(BitStream.DefaultBlockSize);\r\n      \r\n        if (this.buffer.length * 2 <= this.index) {\r\n          throw new Error('invalid index');\r\n        } else if (this.buffer.length <= this.index) {\r\n          this.expandBuffer();\r\n        }\r\n    }\r\n\r\n    public expandBuffer() {\r\n        let oldbuf = this.buffer;\r\n        let i = 0;\r\n        let il = oldbuf.length;\r\n        let buffer: Uint8Array | Array<any> = new (USE_TYPEDARRAY ? Uint8Array : Array)(il << 1);\r\n        // copy buffer\r\n        if(USE_TYPEDARRAY) {\r\n            let uint8Buffer = new Uint8Array(il << 1);\r\n            uint8Buffer.set(oldbuf);\r\n            return (this.buffer = uint8Buffer); \r\n        } else {\r\n            let arrayBuffer = new Array(il << 1);\r\n            for (i = 0; i < il; ++i) {\r\n                arrayBuffer[i] = oldbuf[i];\r\n            }\r\n            return (this.buffer = arrayBuffer);\r\n        }\r\n      }\r\n\r\n    public writeBits(number: number, n: number, reverse?: boolean) {\r\n        let buffer = this.buffer;\r\n        let index = this.index;\r\n        let bitindex =this.bitindex;\r\n\r\n        let current = buffer[index];\r\n        let i;\r\n\r\n        const rev32_ = ( num: number) => {\r\n            return (BitStream.ReverseTable[num & 0xFF] << 24) |\r\n            (BitStream.ReverseTable[num >>> 8 & 0xFF] << 16) |\r\n            (BitStream.ReverseTable[num >>> 16 & 0xFF] << 8) |\r\n            BitStream.ReverseTable[num >>> 24 & 0xFF];\r\n        }\r\n\r\n        if (reverse && n > 1) {\r\n            number = n > 8 ?\r\n            rev32_(number) >> (32 - n) :\r\n            BitStream.ReverseTable[number] >> (8 - n);\r\n        }\r\n\r\n        if (n + bitindex < 8) {\r\n            current = (current << n) | number;\r\n            bitindex += n;\r\n        } else {\r\n            for (i = 0; i < n; ++i){\r\n            current = (current << 1) | ((number >> n - i - 1) & 1);\r\n\r\n            // next byte\r\n            if (++bitindex === 8) {\r\n                bitindex = 0;\r\n                buffer[index++] = BitStream.ReverseTable[current];\r\n                current = 0;\r\n\r\n                // expand\r\n                if (index === buffer.length) {\r\n                buffer = this.expandBuffer();\r\n                }\r\n            }\r\n            }\r\n        }\r\n        buffer[index] = current;\r\n        this.buffer = buffer;\r\n        this.bitindex = bitindex;\r\n        this.index = index;\r\n    }\r\n   \r\n    public finish () {\r\n        let buffer = this.buffer;\r\n        let index = this.index;\r\n        let output: any = null;\r\n        \r\n        if (this.bitindex > 0) {\r\n                buffer[index] <<= 8 - this.bitindex;\r\n                buffer[index] = BitStream.ReverseTable[buffer[index]];\r\n                index++;\r\n        }\r\n        // array truncation\r\n        if (USE_TYPEDARRAY) {\r\n            output = buffer.subarray(0, index);\r\n        } else {\r\n            buffer.length = index;\r\n                output = buffer;\r\n        }\r\n        return output;\r\n    }\r\n    private getReverseTable() {\r\n        let table = new (USE_TYPEDARRAY ? Uint8Array : Array)(256);\r\n        let i = 0;\r\n           \r\n        for (; i < 256; ++i) {\r\n            table[i] = ((n) => {\r\n                let r = n;\r\n                let s = 7;\r\n                for (n >>>= 1; n; n >>>= 1) {\r\n                    r <<= 1;\r\n                    r |= n & 1;\r\n                    --s;\r\n                }\r\n                return (r << s & 0xff) >>> 0;\r\n            })(i);\r\n        }\r\n        return table;\r\n    }\r\n}\r\n","import { ZlibT } from './zlibt';\r\nimport { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\n\r\nexport enum CompressionMethod {\r\n    STORE=   0,\r\n    DEFLATE= 8\r\n};\r\n  \r\nexport enum OperatingSystem {\r\n    MSDOS=  0,\r\n    UNIX=   3,\r\n    MACINTOSH= 7\r\n};\r\n  \r\nexport enum Flags {\r\n    ENCRYPT=    0x0001,\r\n    DESCRIPTOR= 0x0008,\r\n    UTF8=       0x0800\r\n};\r\n  \r\nexport class Zip {\r\n\r\n    public files = [];\r\n    public comment: Array<number>|Uint8Array;\r\n    public password: Array<number>|Uint8Array;\r\n    public static CompressionMethod = CompressionMethod;\r\n    public static OperatingSystem = OperatingSystem;\r\n    public static Flags = Flags;\r\n    constructor(opt_params: any) {\r\n        opt_params = opt_params || {};\r\n        this.files = [];\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n        this.comment = opt_params['comment'];\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n    }\r\n\r\n    public static FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];\r\n\r\n    public static LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];\r\n\r\n    public static CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];\r\n\r\n    public addFile(input: Array<number> | Uint8Array, opt_params: any) {\r\n        opt_params = opt_params || {};\r\n        /** @type {string} */\r\n        let filename = '' || opt_params['filename'];\r\n        /** @type {boolean} */\r\n        let compressed;\r\n        /** @type {number} */\r\n        let size = input.length;\r\n        /** @type {number} */\r\n        let crc32 = 0;\r\n      \r\n        if (USE_TYPEDARRAY && input instanceof Array) {\r\n          input = new Uint8Array(input);\r\n        }\r\n      \r\n        // default\r\n        if (typeof opt_params['compressionMethod'] !== 'number') {\r\n          opt_params['compressionMethod'] = Zip.CompressionMethod.DEFLATE;\r\n        }\r\n      \r\n        // \r\n        if (opt_params['compress']) {\r\n          switch (opt_params['compressionMethod']) {\r\n            case Zip.CompressionMethod.STORE:\r\n              break;\r\n            case Zip.CompressionMethod.DEFLATE:\r\n              crc32 = ZlibT.CRC32.calc(input);\r\n              input = this.deflateWithOption(input, opt_params);\r\n              compressed = true;\r\n              break;\r\n            default:\r\n              throw new Error('unknown compression method:' + opt_params['compressionMethod']);\r\n          }\r\n        }\r\n      \r\n        this.files.push({\r\n          buffer: input,\r\n          option: opt_params,\r\n          compressed: compressed,\r\n          encrypted: false,\r\n          size: size,\r\n          crc32: crc32\r\n        });\r\n    }\r\n\r\n    public setPassword(password: Array<number>|Uint8Array) {\r\n        this.password = password;\r\n    }\r\n\r\n    public compress() {\r\n        let files = this.files;\r\n        let file;\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let output;\r\n        /** @type {number} */\r\n        let op1;\r\n        /** @type {number} */\r\n        let op2;\r\n        /** @type {number} */\r\n        let op3;\r\n        /** @type {number} */\r\n        let localFileSize = 0;\r\n        /** @type {number} */\r\n        let centralDirectorySize = 0;\r\n        /** @type {number} */\r\n        let endOfCentralDirectorySize;\r\n        /** @type {number} */\r\n        let offset;\r\n        /** @type {number} */\r\n        let needVersion;\r\n        /** @type {number} */\r\n        let flags;\r\n        /** @type {Zlib.Zip.CompressionMethod} */\r\n        let compressionMethod;\r\n        /** @type {Date} */\r\n        let date;\r\n        /** @type {number} */\r\n        let crc32;\r\n        /** @type {number} */\r\n        let size;\r\n        /** @type {number} */\r\n        let plainSize;\r\n        /** @type {number} */\r\n        let filenameLength;\r\n        /** @type {number} */\r\n        let extraFieldLength;\r\n        /** @type {number} */\r\n        let commentLength;\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n        let filename;\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n        let extraField;\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n        let comment;\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n        let buffer;\r\n        /** @type {*} */\r\n        let tmp;\r\n        /** @type {Array.<number>|Uint32Array|Object} */\r\n        let key;\r\n        /** @type {number} */\r\n        let i;\r\n        /** @type {number} */\r\n        let il;\r\n        /** @type {number} */\r\n        let j;\r\n        /** @type {number} */\r\n        let jl;\r\n\r\n        for (i = 0, il = files.length; i < il; ++i) {\r\n          file = files[i];\r\n          filenameLength =\r\n            (file.option['filename']) ? file.option['filename'].length : 0;\r\n          extraFieldLength =\r\n            (file.option['extraField']) ? file.option['extraField'].length : 0;\r\n          commentLength =\r\n            (file.option['comment']) ? file.option['comment'].length : 0;\r\n      \r\n          // \r\n          if (!file.compressed) {\r\n            //  CRC32 \r\n            file.crc32 = ZlibT.CRC32.calc(file.buffer);\r\n      \r\n            switch (file.option['compressionMethod']) {\r\n              case Zip.CompressionMethod.STORE:\r\n                break;\r\n              case Zip.CompressionMethod.DEFLATE:\r\n                file.buffer = this.deflateWithOption(file.buffer, file.option);\r\n                file.compressed = true;\r\n                break;\r\n              default:\r\n                throw new Error('unknown compression method:' + file.option['compressionMethod']);\r\n            }\r\n          }\r\n      \r\n          // encryption\r\n          if (file.option['password'] !== void 0|| this.password !== void 0) {\r\n            // init encryption\r\n            key = Zip.createEncryptionKey(file.option['password'] || this.password);\r\n      \r\n            // add header\r\n            buffer = file.buffer;\r\n            if (USE_TYPEDARRAY) {\r\n              tmp = new Uint8Array(buffer.length + 12);\r\n              tmp.set(buffer, 12);\r\n              buffer = tmp;\r\n            } else {\r\n              buffer.unshift(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\n            }\r\n      \r\n            for (j = 0; j < 12; ++j) {\r\n              buffer[j] = this.encode(\r\n                key,\r\n                i === 11 ? (file.crc32 & 0xff) : (Math.random() * 256 | 0)\r\n              );\r\n            }\r\n      \r\n            // data encryption\r\n            for (jl = buffer.length; j < jl; ++j) {\r\n              buffer[j] = this.encode(key, buffer[j]);\r\n            }\r\n            file.buffer = buffer;\r\n          }\r\n      \r\n          // \r\n          localFileSize +=\r\n            // local file header\r\n            30 + filenameLength +\r\n            // file data\r\n            file.buffer.length;\r\n      \r\n          centralDirectorySize +=\r\n            // file header\r\n            46 + filenameLength + commentLength;\r\n        }\r\n      \r\n        // end of central directory\r\n        endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);\r\n        output = new (USE_TYPEDARRAY ? Uint8Array : Array)(\r\n          localFileSize + centralDirectorySize + endOfCentralDirectorySize\r\n        );\r\n        op1 = 0;\r\n        op2 = localFileSize;\r\n        op3 = op2 + centralDirectorySize;\r\n      \r\n        // \r\n        for (i = 0, il = files.length; i < il; ++i) {\r\n          file = files[i];\r\n          filenameLength =\r\n            file.option['filename'] ? file.option['filename'].length :  0;\r\n          extraFieldLength = 0; // TODO\r\n          commentLength =\r\n            file.option['comment'] ? file.option['comment'].length : 0;\r\n      \r\n          //-------------------------------------------------------------------------\r\n          // local file header & file header\r\n          //-------------------------------------------------------------------------\r\n      \r\n          offset = op1;\r\n      \r\n          // signature\r\n          // local file header\r\n          output[op1++] = Zip.LocalFileHeaderSignature[0];\r\n          output[op1++] = Zip.LocalFileHeaderSignature[1];\r\n          output[op1++] = Zip.LocalFileHeaderSignature[2];\r\n          output[op1++] = Zip.LocalFileHeaderSignature[3];\r\n          // file header\r\n          output[op2++] = Zip.FileHeaderSignature[0];\r\n          output[op2++] = Zip.FileHeaderSignature[1];\r\n          output[op2++] = Zip.FileHeaderSignature[2];\r\n          output[op2++] = Zip.FileHeaderSignature[3];\r\n      \r\n          // compressor info\r\n          needVersion = 20;\r\n          output[op2++] = needVersion & 0xff;\r\n          output[op2++] =\r\n            /** @type {Zlib.Zip.OperatingSystem} */\r\n            (file.option['os']) ||\r\n            Zip.OperatingSystem.MSDOS;\r\n      \r\n          // need version\r\n          output[op1++] = output[op2++] =  needVersion       & 0xff;\r\n          output[op1++] = output[op2++] = (needVersion >> 8) & 0xff;\r\n      \r\n          // general purpose bit flag\r\n          flags = 0;\r\n          if (file.option['password'] || this.password) {\r\n            flags |= Zip.Flags.ENCRYPT;\r\n          }\r\n          output[op1++] = output[op2++] =  flags       & 0xff;\r\n          output[op1++] = output[op2++] = (flags >> 8) & 0xff;\r\n      \r\n          // compression method\r\n          compressionMethod =\r\n            /** @type {Zlib.Zip.CompressionMethod} */\r\n            (file.option['compressionMethod']);\r\n          output[op1++] = output[op2++] =  compressionMethod       & 0xff;\r\n          output[op1++] = output[op2++] = (compressionMethod >> 8) & 0xff;\r\n      \r\n          // date\r\n          date = /** @type {(Date|undefined)} */(file.option['date']) || new Date();\r\n          output[op1++] = output[op2++] =\r\n            ((date.getMinutes() & 0x7) << 5) |\r\n            (date.getSeconds() / 2 | 0);\r\n          output[op1++] = output[op2++] =\r\n            (date.getHours()   << 3) |\r\n            (date.getMinutes() >> 3);\r\n          //\r\n          output[op1++] = output[op2++] =\r\n            ((date.getMonth() + 1 & 0x7) << 5) |\r\n            (date.getDate());\r\n          output[op1++] = output[op2++] =\r\n            ((date.getFullYear() - 1980 & 0x7f) << 1) |\r\n            (date.getMonth() + 1 >> 3);\r\n      \r\n          // CRC-32\r\n          crc32 = file.crc32;\r\n          output[op1++] = output[op2++] =  crc32        & 0xff;\r\n          output[op1++] = output[op2++] = (crc32 >>  8) & 0xff;\r\n          output[op1++] = output[op2++] = (crc32 >> 16) & 0xff;\r\n          output[op1++] = output[op2++] = (crc32 >> 24) & 0xff;\r\n      \r\n          // compressed size\r\n          size = file.buffer.length;\r\n          output[op1++] = output[op2++] =  size        & 0xff;\r\n          output[op1++] = output[op2++] = (size >>  8) & 0xff;\r\n          output[op1++] = output[op2++] = (size >> 16) & 0xff;\r\n          output[op1++] = output[op2++] = (size >> 24) & 0xff;\r\n      \r\n          // uncompressed size\r\n          plainSize = file.size;\r\n          output[op1++] = output[op2++] =  plainSize        & 0xff;\r\n          output[op1++] = output[op2++] = (plainSize >>  8) & 0xff;\r\n          output[op1++] = output[op2++] = (plainSize >> 16) & 0xff;\r\n          output[op1++] = output[op2++] = (plainSize >> 24) & 0xff;\r\n      \r\n          // filename length\r\n          output[op1++] = output[op2++] =  filenameLength       & 0xff;\r\n          output[op1++] = output[op2++] = (filenameLength >> 8) & 0xff;\r\n      \r\n          // extra field length\r\n          output[op1++] = output[op2++] =  extraFieldLength       & 0xff;\r\n          output[op1++] = output[op2++] = (extraFieldLength >> 8) & 0xff;\r\n      \r\n          // file comment length\r\n          output[op2++] =  commentLength       & 0xff;\r\n          output[op2++] = (commentLength >> 8) & 0xff;\r\n      \r\n          // disk number start\r\n          output[op2++] = 0;\r\n          output[op2++] = 0;\r\n      \r\n          // internal file attributes\r\n          output[op2++] = 0;\r\n          output[op2++] = 0;\r\n      \r\n          // external file attributes\r\n          output[op2++] = 0;\r\n          output[op2++] = 0;\r\n          output[op2++] = 0;\r\n          output[op2++] = 0;\r\n      \r\n          // relative offset of local header\r\n          output[op2++] =  offset        & 0xff;\r\n          output[op2++] = (offset >>  8) & 0xff;\r\n          output[op2++] = (offset >> 16) & 0xff;\r\n          output[op2++] = (offset >> 24) & 0xff;\r\n      \r\n          // filename\r\n          filename = file.option['filename'];\r\n          if (filename) {\r\n            if (USE_TYPEDARRAY) {\r\n              output.set(filename, op1);\r\n              output.set(filename, op2);\r\n              op1 += filenameLength;\r\n              op2 += filenameLength;\r\n            } else {\r\n              for (j = 0; j < filenameLength; ++j) {\r\n                output[op1++] = output[op2++] = filename[j];\r\n              }\r\n            }\r\n          }\r\n      \r\n          // extra field\r\n          extraField = file.option['extraField'];\r\n          if (extraField) {\r\n            if (USE_TYPEDARRAY) {\r\n              output.set(extraField, op1);\r\n              output.set(extraField, op2);\r\n              op1 += extraFieldLength;\r\n              op2 += extraFieldLength;\r\n            } else {\r\n              for (j = 0; j < commentLength; ++j) {\r\n                output[op1++] = output[op2++] = extraField[j];\r\n              }\r\n            }\r\n          }\r\n      \r\n          // comment\r\n          comment = file.option['comment'];\r\n          if (comment) {\r\n            if (USE_TYPEDARRAY) {\r\n              output.set(comment, op2);\r\n              op2 += commentLength;\r\n            } else {\r\n              for (j = 0; j < commentLength; ++j) {\r\n                output[op2++] = comment[j];\r\n              }\r\n            }\r\n          }\r\n      \r\n          //-------------------------------------------------------------------------\r\n          // file data\r\n          //-------------------------------------------------------------------------\r\n      \r\n          if (USE_TYPEDARRAY) {\r\n            output.set(file.buffer, op1);\r\n            op1 += file.buffer.length;\r\n          } else {\r\n            for (j = 0, jl = file.buffer.length; j < jl; ++j) {\r\n              output[op1++] = file.buffer[j];\r\n            }\r\n          }\r\n        }\r\n      \r\n        //-------------------------------------------------------------------------\r\n        // end of central directory\r\n        //-------------------------------------------------------------------------\r\n      \r\n        // signature\r\n        output[op3++] = Zip.CentralDirectorySignature[0];\r\n        output[op3++] = Zip.CentralDirectorySignature[1];\r\n        output[op3++] = Zip.CentralDirectorySignature[2];\r\n        output[op3++] = Zip.CentralDirectorySignature[3];\r\n      \r\n        // number of this disk\r\n        output[op3++] = 0;\r\n        output[op3++] = 0;\r\n      \r\n        // number of the disk with the start of the central directory\r\n        output[op3++] = 0;\r\n        output[op3++] = 0;\r\n      \r\n        // total number of entries in the central directory on this disk\r\n        output[op3++] =  il       & 0xff;\r\n        output[op3++] = (il >> 8) & 0xff;\r\n      \r\n        // total number of entries in the central directory\r\n        output[op3++] =  il       & 0xff;\r\n        output[op3++] = (il >> 8) & 0xff;\r\n      \r\n        // size of the central directory\r\n        output[op3++] =  centralDirectorySize        & 0xff;\r\n        output[op3++] = (centralDirectorySize >>  8) & 0xff;\r\n        output[op3++] = (centralDirectorySize >> 16) & 0xff;\r\n        output[op3++] = (centralDirectorySize >> 24) & 0xff;\r\n      \r\n        // offset of start of central directory with respect to the starting disk number\r\n        output[op3++] =  localFileSize        & 0xff;\r\n        output[op3++] = (localFileSize >>  8) & 0xff;\r\n        output[op3++] = (localFileSize >> 16) & 0xff;\r\n        output[op3++] = (localFileSize >> 24) & 0xff;\r\n      \r\n        // .ZIP file comment length\r\n        commentLength = this.comment ? this.comment.length : 0;\r\n        output[op3++] =  commentLength       & 0xff;\r\n        output[op3++] = (commentLength >> 8) & 0xff;\r\n      \r\n        // .ZIP file comment\r\n        if (this.comment) {\r\n          if (USE_TYPEDARRAY) {\r\n            output.set(this.comment, op3);\r\n            op3 += commentLength;\r\n          } else {\r\n            for (j = 0, jl = commentLength; j < jl; ++j) {\r\n              output[op3++] = this.comment[j];\r\n            }\r\n          }\r\n        } \r\n        return output;\r\n    }\r\n\r\n    public deflateWithOption(input: Array<number> | Uint8Array, opt_params: Object) {\r\n        /** @type {Zlib.RawDeflate} */\r\n        const deflator = new ZlibT.RawDeflate(input, opt_params['deflateOption']);\r\n      \r\n        return deflator.compress();\r\n    }\r\n\r\n    public static getByte(key: Array<number> | Uint32Array) {\r\n        const tmp = ((key[2] & 0xffff) | 2);\r\n        return ((tmp * (tmp ^ 1)) >> 8) & 0xff;\r\n    };\r\n\r\n    public encode(key: Array<number> | Uint32Array, n: number) {\r\n        /** @type {number} */\r\n        const tmp = Zip.getByte(key);\r\n      \r\n        Zip.updateKeys(key, n);\r\n      \r\n        return tmp ^ n;\r\n    };\r\n\r\n    public static updateKeys = function(key: Array<number> | Uint32Array, n: number) {\r\n            key[0] = ZlibT.CRC32.single(key[0], n);\r\n            key[1] =\r\n            (((((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681) >>> 0) + 1) >>> 0;\r\n            key[2] = ZlibT.CRC32.single(key[2], key[1] >>> 24);\r\n    }\r\n    \r\n    public static createEncryptionKey(password: Array<number>|Uint8Array) {\r\n        /** @type {!(Array.<number>|Uint32Array)} */\r\n        const keyOrigin = [305419896, 591751049, 878082192];\r\n        /** @type {number} */\r\n        let i = 0 ;\r\n        /** @type {number} */\r\n        let il = password.length;\r\n        let key = USE_TYPEDARRAY ? new Uint32Array(keyOrigin) : keyOrigin;\r\n    \r\n        for (; i < il; ++i) {\r\n            Zip.updateKeys(key, password[i] & 0xff);\r\n        }\r\n        return key;\r\n    }\r\n}\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\nexport let ZLIB_CRC32_COMPACT = false;\r\nexport class CRC32 {\r\n    constructor() {\r\n    }\r\n    public static calc(data: Array<number> | Uint8Array, pos?: number, length?: number) {\r\n        return this.update(data, 0, pos, length);\r\n    }\r\n    public static update = function(data: Array<number> | Uint8Array, crc: number, pos: number, length: number) {\r\n        let table = CRC32.Table;\r\n        let i = (typeof pos === 'number') ? pos : (pos = 0);\r\n        let il = (typeof length === 'number') ? length : data.length;\r\n        crc ^= 0xffffffff;\r\n        // loop unrolling for performance\r\n        for (i = il & 7; i--; ++pos) {\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];\r\n        }\r\n        for (i = il >> 3; i--; pos += 8) {\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos    ]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 1]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 2]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 3]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 4]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 5]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 6]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 7]) & 0xff];\r\n        }\r\n        return (crc ^ 0xffffffff) >>> 0;\r\n    }\r\n    public static single(num: number, crc: number) {\r\n        return (CRC32.Table[(num ^ crc) & 0xff] ^ (num >>> 8)) >>> 0;\r\n    };\r\n    public static Table_ = [\r\n        0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\r\n        0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\r\n        0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\r\n        0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\r\n        0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\r\n        0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\r\n        0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\r\n        0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\r\n        0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\r\n        0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\r\n        0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\r\n        0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\r\n        0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\r\n        0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\r\n        0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\r\n        0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\r\n        0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\r\n        0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\r\n        0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\r\n        0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\r\n        0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\r\n        0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\r\n        0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\r\n        0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\r\n        0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\r\n        0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\r\n        0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\r\n        0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\r\n        0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\r\n        0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\r\n        0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\r\n        0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\r\n        0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\r\n        0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\r\n        0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\r\n        0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\r\n        0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\r\n        0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\r\n        0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\r\n        0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\r\n        0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\r\n        0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\r\n        0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\r\n      ];\r\n      public static get Table() {\r\n        if (ZLIB_CRC32_COMPACT) {\r\n            let table = new (USE_TYPEDARRAY ? Uint32Array : Array)(256);\r\n            let c: number;\r\n            let i: number;\r\n            let j: number;\r\n          \r\n            for (i = 0; i < 256; ++i) {\r\n              c = i;\r\n              for (j = 0; j < 8; ++j) {\r\n                c = (c & 1) ? (0xedB88320 ^ (c >>> 1)) : (c >>> 1);\r\n              }\r\n              table[i] = c >>> 0;\r\n            }\r\n          \r\n            return table\r\n        } else if (USE_TYPEDARRAY) {\r\n            return new Uint32Array(CRC32.Table_);\r\n        } else {\r\n            return CRC32.Table_;\r\n        }\r\n    }\r\n}\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\n\r\nexport class Heap {\r\n    \r\n    public buffer: Uint16Array | Array<number>;\r\n    public length: number;\r\n    \r\n    constructor(length: number) {\r\n        this.buffer = new (USE_TYPEDARRAY ? Uint16Array : Array)(length * 2);\r\n        this.length = 0;\r\n    }\r\n\r\n    public getParent(index: number) {\r\n        return ((index - 2) / 4 | 0) * 2;\r\n    };\r\n\r\n    public getChild = function(index: number) {\r\n        return 2 * index + 2;\r\n    };\r\n\r\n    public push(index: number, value: number) {\r\n        let current, parent,\r\n            heap = this.buffer,\r\n            swap;\r\n      \r\n        current = this.length;\r\n        heap[this.length++] = value;\r\n        heap[this.length++] = index;\r\n      \r\n        while (current > 0) {\r\n          parent = this.getParent(current);\r\n      \r\n          if (heap[current] > heap[parent]) {\r\n            swap = heap[current];\r\n            heap[current] = heap[parent];\r\n            heap[parent] = swap;\r\n      \r\n            swap = heap[current + 1];\r\n            heap[current + 1] = heap[parent + 1];\r\n            heap[parent + 1] = swap;\r\n      \r\n            current = parent;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n        return this.length;\r\n    }\r\n\r\n    public pop() {\r\n        let index, value,\r\n            heap = this.buffer, swap,\r\n            current, parent;\r\n      \r\n        value = heap[0];\r\n        index = heap[1];\r\n      \r\n        this.length -= 2;\r\n        heap[0] = heap[this.length];\r\n        heap[1] = heap[this.length + 1];\r\n      \r\n        parent = 0;\r\n        while (true) {\r\n          current = this.getChild(parent);\r\n      \r\n          if (current >= this.length) {\r\n            break;\r\n          }\r\n      \r\n          if (current + 2 < this.length && heap[current + 2] > heap[current]) {\r\n            current += 2;\r\n          }\r\n      \r\n          if (heap[current] > heap[parent]) {\r\n            swap = heap[parent];\r\n            heap[parent] = heap[current];\r\n            heap[current] = swap;\r\n      \r\n            swap = heap[parent + 1];\r\n            heap[parent + 1] = heap[current + 1];\r\n            heap[current + 1] = swap;\r\n          } else {\r\n            break;\r\n          }\r\n      \r\n          parent = current;\r\n        }\r\n        return {index: index, value: value, length: this.length};\r\n    }\r\n}\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\n\r\n/**\r\n * build huffman table from length list.\r\n * @param {!(Array.<number>|Uint8Array)} lengths length list.\r\n * @return {!Array} huffman table.\r\n */\r\nexport class Huffman {\r\n    constructor() {\r\n    \r\n    }\r\n    public static buildHuffmanTable(lengths: Array<number>|Uint8Array) {\r\n        /** @type {number} length list size. */\r\n        let listSize = lengths.length;\r\n        /** @type {number} max code length for table size. */\r\n        let maxCodeLength = 0;\r\n        /** @type {number} min code length for table size. */\r\n        let minCodeLength = Number.POSITIVE_INFINITY;\r\n        /** @type {number} table size. */\r\n        let size;\r\n        /** @type {!(Array|Uint8Array)} huffman code table. */\r\n        let table;\r\n        /** @type {number} bit length. */\r\n        let bitLength;\r\n        /** @type {number} huffman code. */\r\n        let code;\r\n        /**\r\n         *  2^maxlength .\r\n         * @type {number} skip length for table filling.\r\n         */\r\n        let skip;\r\n        /** @type {number} reversed code. */\r\n        let reversed;\r\n        /** @type {number} reverse temp. */\r\n        let rtemp;\r\n        /** @type {number} loop counter. */\r\n        let i;\r\n        /** @type {number} loop limit. */\r\n        let il;\r\n        /** @type {number} loop counter. */\r\n        let j;\r\n        /** @type {number} table value. */\r\n        let value;\r\n\r\n        // Math.max  for-loop \r\n        for (i = 0, il = listSize; i < il; ++i) {\r\n            if (lengths[i] > maxCodeLength) {\r\n            maxCodeLength = lengths[i];\r\n            }\r\n            if (lengths[i] < minCodeLength) {\r\n            minCodeLength = lengths[i];\r\n            }\r\n        }\r\n\r\n        size = 1 << maxCodeLength;\r\n        table = new (USE_TYPEDARRAY ? Uint32Array : Array)(size);\r\n\r\n        // \r\n        for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {\r\n            for (i = 0; i < listSize; ++i) {\r\n            if (lengths[i] === bitLength) {\r\n                // \r\n                for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {\r\n                reversed = (reversed << 1) | (rtemp & 1);\r\n                rtemp >>= 1;\r\n                }\r\n\r\n                // \r\n                //  0 / 1 \r\n                // \r\n                // \r\n                value = (bitLength << 16) | i;\r\n                for (j = reversed; j < size; j += skip) {\r\n                table[j] = value;\r\n                }\r\n\r\n                ++code;\r\n            }\r\n            }\r\n\r\n            // \r\n            ++bitLength;\r\n            code <<= 1;\r\n            skip <<= 1;\r\n        }\r\n\r\n        return [table, maxCodeLength, minCodeLength];\r\n    }\r\n}\r\n","\r\nimport { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\nimport { ZlibT } from './zlibt';\r\n\r\nenum rBufferType {\r\n    BLOCK= 0,\r\n    ADAPTIVE= 1\r\n};\r\nexport class RawInflate{\r\n    public static ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; \r\n    public static buildHuffmanTable = ZlibT.Huffman.buildHuffmanTable;\r\n    public static BufferType = rBufferType;\r\n\r\n    public static MaxBackwardLength = 32768;\r\n    public static MaxCopyLength = 258;\r\n\r\n    public currentLitlenTable: Array<number> | Uint16Array;\r\n    public static Order = (() =>{\r\n        const table = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n    })();\r\n\r\n    public static LengthCodeTable = ((table) => {\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n    })([\r\n        0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\r\n        0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\r\n        0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\r\n        0x00e3, 0x0102, 0x0102, 0x0102\r\n    ]);\r\n\r\n    public static LengthExtraTable = ((table) => {\r\n        return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n    })([\r\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\r\n        5, 5, 0, 0, 0\r\n    ]);\r\n\r\n    public static DistCodeTable = ((table) => {\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n      })([\r\n        0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\r\n        0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\r\n        0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\r\n        0x3001, 0x4001, 0x6001\r\n      ]);\r\n\r\n    public static DistExtraTable = (() => {\r\n        const table = [\r\n            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\r\n            11, 12, 12, 13, 13\r\n          ]\r\n        return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n    })()\r\n\r\n    public static FixedLiteralLengthTable = (() => {\r\n        let lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);\r\n        let i, il;\r\n      \r\n        for (i = 0, il = lengths.length; i < il; ++i) {\r\n          lengths[i] =\r\n            (i <= 143) ? 8 :\r\n            (i <= 255) ? 9 :\r\n            (i <= 279) ? 7 :\r\n            8;\r\n        }\r\n      \r\n        return RawInflate.buildHuffmanTable(lengths)\r\n    })();\r\n\r\n    public static FixedDistanceTable = ((table) => {\r\n        let lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);\r\n        let i, il;\r\n      \r\n        for (i = 0, il = lengths.length; i < il; ++i) {\r\n          lengths[i] = 5;\r\n        }\r\n      \r\n        return RawInflate.buildHuffmanTable(lengths)\r\n    })();\r\n\r\n    public buffer: Array<number>|Uint8Array;\r\n    public blocks: Array<(Array<number>|Uint8Array)>;\r\n    public bufferSize: number;\r\n    public totalpos: number;\r\n    public ip;\r\n    public bitsbuf;\r\n    public bitsbuflen;\r\n    public input: Array<number>|Uint8Array;\r\n    public output: Array<number>|Uint8Array;\r\n    /** @type {!number} output buffer pointer. */\r\n    public op: number;\r\n    /** @type {boolean} is final block flag. */\r\n    public bfinal = false;\r\n    /** @type {Zlib.RawInflate.BufferType} buffer management. */\r\n    public bufferType = RawInflate.BufferType.ADAPTIVE;\r\n    /** @type {boolean} resize flag for memory size optimization. */\r\n    public resize = false;\r\n    constructor(input: Uint8Array | Array<number>, opt_params: any) {\r\n        /** @type {!Array.<(Array.<number>|Uint8Array)>} */\r\n        this.blocks = [];\r\n        /** @type {number} block size. */\r\n        this.bufferSize = RawInflate.ZLIB_RAW_INFLATE_BUFFER_SIZE;\r\n        /** @type {!number} total output buffer pointer. */\r\n        this.totalpos = 0;\r\n        /** @type {!number} input buffer pointer. */\r\n        this.ip = 0;\r\n        /** @type {!number} bit stream reader buffer. */\r\n        this.bitsbuf = 0;\r\n        /** @type {!number} bit stream reader buffer size. */\r\n        this.bitsbuflen = 0;\r\n        /** @type {!(Array.<number>|Uint8Array)} input buffer. */\r\n        this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;\r\n        /** @type {boolean} is final block flag. */\r\n        this.bfinal = false;\r\n        /** @type {Zlib.RawInflate.BufferType} buffer management. */\r\n        this.bufferType = RawInflate.BufferType.ADAPTIVE;\r\n        /** @type {boolean} resize flag for memory size optimization. */\r\n        this.resize = false;\r\n    \r\n    // option parameters\r\n        if (opt_params || !(opt_params = {})) {\r\n            if (opt_params['index']) {\r\n            this.ip = opt_params['index'];\r\n            }\r\n            if (opt_params['bufferSize']) {\r\n            this.bufferSize = opt_params['bufferSize'];\r\n            }\r\n            if (opt_params['bufferType']) {\r\n            this.bufferType = opt_params['bufferType'];\r\n            }\r\n            if (opt_params['resize']) {\r\n            this.resize = opt_params['resize'];\r\n            }\r\n        }\r\n    \r\n    // initialize\r\n        switch (this.bufferType) {\r\n            case RawInflate.BufferType.BLOCK:\r\n            this.op = RawInflate.MaxBackwardLength;\r\n            this.output =\r\n                new (USE_TYPEDARRAY ? Uint8Array : Array)(\r\n                RawInflate.MaxBackwardLength +\r\n                this.bufferSize +\r\n                RawInflate.MaxCopyLength\r\n                );\r\n            break;\r\n            case RawInflate.BufferType.ADAPTIVE:\r\n            this.op = 0;\r\n            this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);\r\n            break;\r\n            default:\r\n            throw new Error('invalid inflate mode');\r\n        }\r\n    }\r\n\r\n    public decompress() {\r\n        while (!this.bfinal) {\r\n          this.parseBlock();\r\n        }\r\n        switch (this.bufferType) {\r\n          case RawInflate.BufferType.BLOCK:\r\n            return this.concatBufferBlock();\r\n          case RawInflate.BufferType.ADAPTIVE:\r\n            return this.concatBufferDynamic();\r\n          default:\r\n            throw new Error('invalid inflate mode');\r\n        }\r\n    }\r\n    public parseBlock() {\r\n        /** @type {number} header */\r\n        let hdr = this.readBits(3);\r\n      \r\n        // BFINAL\r\n        if (hdr & 0x1) {\r\n          this.bfinal = true;\r\n        }\r\n      \r\n        // BTYPE\r\n        hdr >>>= 1;\r\n        switch (hdr) {\r\n          // uncompressed\r\n          case 0:\r\n            this.parseUncompressedBlock();\r\n            break;\r\n          // fixed huffman\r\n          case 1:\r\n            this.parseFixedHuffmanBlock();\r\n            break;\r\n          // dynamic huffman\r\n          case 2:\r\n            this.parseDynamicHuffmanBlock();\r\n            break;\r\n          // reserved or other\r\n          default:\r\n            throw new Error('unknown BTYPE: ' + hdr);\r\n        }\r\n    }\r\n    public readBits(length) {\r\n        let bitsbuf = this.bitsbuf;\r\n        let bitsbuflen = this.bitsbuflen;\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n      \r\n        /** @type {number} */\r\n        let inputLength = input.length;\r\n        /** @type {number} input and output byte. */\r\n        let octet;\r\n      \r\n        // input byte\r\n        if (ip + ((length - bitsbuflen + 7) >> 3) >= inputLength) {\r\n          throw new Error('input buffer is broken');\r\n        }\r\n      \r\n        // not enough buffer\r\n        while (bitsbuflen < length) {\r\n          bitsbuf |= input[ip++] << bitsbuflen;\r\n          bitsbuflen += 8;\r\n        }\r\n      \r\n        // output byte\r\n        octet = bitsbuf & /* MASK */ ((1 << length) - 1);\r\n        bitsbuf >>>= length;\r\n        bitsbuflen -= length;\r\n      \r\n        this.bitsbuf = bitsbuf;\r\n        this.bitsbuflen = bitsbuflen;\r\n        this.ip = ip;\r\n      \r\n        return octet;\r\n    }\r\n\r\n    public readCodeByTable(table) {\r\n        let bitsbuf = this.bitsbuf;\r\n        let bitsbuflen = this.bitsbuflen;\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n      \r\n        /** @type {number} */\r\n        let inputLength = input.length;\r\n        /** @type {!(Array.<number>|Uint8Array)} huffman code table */\r\n        let codeTable = table[0];\r\n        /** @type {number} */\r\n        let maxCodeLength = table[1];\r\n        /** @type {number} code length & code (16bit, 16bit) */\r\n        let codeWithLength;\r\n        /** @type {number} code bits length */\r\n        let codeLength;\r\n      \r\n        // not enough buffer\r\n        while (bitsbuflen < maxCodeLength) {\r\n          if (ip >= inputLength) {\r\n            break;\r\n          }\r\n          bitsbuf |= input[ip++] << bitsbuflen;\r\n          bitsbuflen += 8;\r\n        }\r\n      \r\n        // read max length\r\n        codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\r\n        codeLength = codeWithLength >>> 16;\r\n      \r\n        if (codeLength > bitsbuflen) {\r\n          throw new Error('invalid code length: ' + codeLength);\r\n        }\r\n      \r\n        this.bitsbuf = bitsbuf >> codeLength;\r\n        this.bitsbuflen = bitsbuflen - codeLength;\r\n        this.ip = ip;\r\n      \r\n        return codeWithLength & 0xffff;\r\n      }\r\n\r\n      public parseUncompressedBlock() {\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n        let output = this.output;\r\n        let op = this.op;\r\n      \r\n        /** @type {number} */\r\n        let inputLength = input.length;\r\n        /** @type {number} block length */\r\n        let len;\r\n        /** @type {number} number for check block length */\r\n        let nlen;\r\n        /** @type {number} output buffer length */\r\n        let olength = output.length;\r\n        /** @type {number} copy counter */\r\n        let preCopy;\r\n      \r\n        // skip buffered header bits\r\n        this.bitsbuf = 0;\r\n        this.bitsbuflen = 0;\r\n      \r\n        // len\r\n        if (ip + 1 >= inputLength) {\r\n          throw new Error('invalid uncompressed block header: LEN');\r\n        }\r\n        len = input[ip++] | (input[ip++] << 8);\r\n      \r\n        // nlen\r\n        if (ip + 1 >= inputLength) {\r\n          throw new Error('invalid uncompressed block header: NLEN');\r\n        }\r\n        nlen = input[ip++] | (input[ip++] << 8);\r\n      \r\n        // check len & nlen\r\n        if (len === ~nlen) {\r\n          throw new Error('invalid uncompressed block header: length verify');\r\n        }\r\n      \r\n        // check size\r\n        if (ip + len > input.length) { throw new Error('input buffer is broken'); }\r\n      \r\n        // expand buffer\r\n        switch (this.bufferType) {\r\n          case RawInflate.BufferType.BLOCK:\r\n            // pre copy\r\n            while (op + len > output.length) {\r\n              preCopy = olength - op;\r\n              len -= preCopy;\r\n              if (USE_TYPEDARRAY) {\r\n                (<Uint8Array>output).set((<Uint8Array>input).subarray(ip, ip + preCopy), op);\r\n                op += preCopy;\r\n                ip += preCopy;\r\n              } else {\r\n                while (preCopy--) {\r\n                  output[op++] = input[ip++];\r\n                }\r\n              }\r\n              this.op = op;\r\n              output = this.expandBufferBlock();\r\n              op = this.op;\r\n            }\r\n            break;\r\n          case RawInflate.BufferType.ADAPTIVE:\r\n            while (op + len > output.length) {\r\n              output = this.expandBufferAdaptive({fixRatio: 2});\r\n            }\r\n            break;\r\n          default:\r\n            throw new Error('invalid inflate mode');\r\n        }\r\n      \r\n        // copy\r\n        if (USE_TYPEDARRAY) {\r\n            (<Uint8Array>output).set((<Uint8Array>input).subarray(ip, ip + len), op);\r\n          op += len;\r\n          ip += len;\r\n        } else {\r\n          while (len--) {\r\n            output[op++] = input[ip++];\r\n          }\r\n        }\r\n      \r\n        this.ip = ip;\r\n        this.op = op;\r\n        this.output = output;\r\n    }\r\n\r\n    public parseFixedHuffmanBlock() {\r\n        switch (this.bufferType) {\r\n          case RawInflate.BufferType.ADAPTIVE:\r\n            this.decodeHuffmanAdaptive(\r\n              RawInflate.FixedLiteralLengthTable,\r\n              RawInflate.FixedDistanceTable\r\n            );\r\n            break;\r\n          case RawInflate.BufferType.BLOCK:\r\n            this.decodeHuffmanBlock(\r\n              RawInflate.FixedLiteralLengthTable,\r\n              RawInflate.FixedDistanceTable\r\n            );\r\n            break;\r\n          default:\r\n            throw new Error('invalid inflate mode');\r\n        }\r\n    }\r\n\r\n    public parseDynamicHuffmanBlock() {\r\n        /** @type {number} number of literal and length codes. */\r\n        let hlit = this.readBits(5) + 257;\r\n        /** @type {number} number of distance codes. */\r\n        let hdist = this.readBits(5) + 1;\r\n        /** @type {number} number of code lengths. */\r\n        let hclen = this.readBits(4) + 4;\r\n        /** @type {!(Uint8Array|Array.<number>)} code lengths. */\r\n        let codeLengths =\r\n          new (USE_TYPEDARRAY ? Uint8Array : Array)(RawInflate.Order.length);\r\n        /** @type {!Array} code lengths table. */\r\n        let codeLengthsTable;\r\n        /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */\r\n        let litlenTable;\r\n        /** @type {!(Uint8Array|Array.<number>)} distance code table. */\r\n        let distTable;\r\n        /** @type {!(Uint8Array|Array.<number>)} code length table. */\r\n        let lengthTable;\r\n        /** @type {number} */\r\n        let code;\r\n        /** @type {number} */\r\n        let prev;\r\n        /** @type {number} */\r\n        let repeat;\r\n        /** @type {number} loop counter. */\r\n        let i;\r\n        /** @type {number} loop limit. */\r\n        let il;\r\n      \r\n        // decode code lengths\r\n        for (i = 0; i < hclen; ++i) {\r\n          codeLengths[RawInflate.Order[i]] = this.readBits(3);\r\n        }\r\n        if (!USE_TYPEDARRAY) {\r\n          for (i = hclen, hclen = codeLengths.length; i < hclen; ++i) {\r\n            codeLengths[RawInflate.Order[i]] = 0;\r\n          }\r\n        }\r\n      \r\n        // decode length table\r\n        codeLengthsTable = RawInflate.buildHuffmanTable(codeLengths);\r\n        lengthTable = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit + hdist);\r\n        for (i = 0, il = hlit + hdist; i < il;) {\r\n          code = this.readCodeByTable(codeLengthsTable);\r\n          switch (code) {\r\n            case 16:\r\n              repeat = 3 + this.readBits(2);\r\n              while (repeat--) { lengthTable[i++] = prev; }\r\n              break;\r\n            case 17:\r\n              repeat = 3 + this.readBits(3);\r\n              while (repeat--) { lengthTable[i++] = 0; }\r\n              prev = 0;\r\n              break;\r\n            case 18:\r\n              repeat = 11 + this.readBits(7);\r\n              while (repeat--) { lengthTable[i++] = 0; }\r\n              prev = 0;\r\n              break;\r\n            default:\r\n              lengthTable[i++] = code;\r\n              prev = code;\r\n              break;\r\n          }\r\n        }\r\n      \r\n        litlenTable = USE_TYPEDARRAY\r\n          ? RawInflate.buildHuffmanTable(lengthTable.subarray(0, hlit))\r\n          : RawInflate.buildHuffmanTable(lengthTable.slice(0, hlit));\r\n        distTable = USE_TYPEDARRAY\r\n          ? RawInflate.buildHuffmanTable(lengthTable.subarray(hlit))\r\n          : RawInflate.buildHuffmanTable(lengthTable.slice(hlit));\r\n      \r\n        switch (this.bufferType) {\r\n          case RawInflate.BufferType.ADAPTIVE:\r\n            this.decodeHuffmanAdaptive(litlenTable, distTable);\r\n            break;\r\n          case RawInflate.BufferType.BLOCK:\r\n            this.decodeHuffmanBlock(litlenTable, distTable);\r\n            break;\r\n          default:\r\n            throw new Error('invalid inflate mode');\r\n        }\r\n    }\r\n\r\n    public decodeHuffmanBlock(litlen: Array<number>|Uint16Array, dist: Array<number>|Uint8Array) {\r\n        let output = this.output;\r\n        let op = this.op;\r\n        \r\n        this.currentLitlenTable = litlen;\r\n        \r\n        /** @type {number} output position limit. */\r\n        let olength = output.length - RawInflate.MaxCopyLength;\r\n        /** @type {number} huffman code. */\r\n        let code;\r\n        /** @type {number} table index. */\r\n        let ti;\r\n        /** @type {number} huffman code distination. */\r\n        let codeDist;\r\n        /** @type {number} huffman code length. */\r\n        let codeLength;\r\n        \r\n        let lengthCodeTable = RawInflate.LengthCodeTable;\r\n        let lengthExtraTable = RawInflate.LengthExtraTable;\r\n        let distCodeTable = RawInflate.DistCodeTable;\r\n        let distExtraTable = RawInflate.DistExtraTable;\r\n        \r\n        code = this.readCodeByTable(litlen);\r\n        while ( code !== 256) {\r\n            // literal\r\n            if (code < 256) {\r\n            if (op >= olength) {\r\n                this.op = op;\r\n                output = this.expandBufferBlock();\r\n                op = this.op;\r\n            }\r\n            output[op++] = code;\r\n        \r\n            continue;\r\n            }\r\n        \r\n            // length code\r\n            ti = code - 257;\r\n            codeLength = lengthCodeTable[ti];\r\n            if (lengthExtraTable[ti] > 0) {\r\n            codeLength += this.readBits(lengthExtraTable[ti]);\r\n            }\r\n        \r\n            // dist code\r\n            code = this.readCodeByTable(dist);\r\n            codeDist = distCodeTable[code];\r\n            if (distExtraTable[code] > 0) {\r\n            codeDist += this.readBits(distExtraTable[code]);\r\n            }\r\n        \r\n            // lz77 decode\r\n            if (op >= olength) {\r\n            this.op = op;\r\n            output = this.expandBufferBlock();\r\n            op = this.op;\r\n            }\r\n            while (codeLength--) {\r\n            output[op] = output[(op++) - codeDist];\r\n            }\r\n            code = this.readCodeByTable(litlen);\r\n        }\r\n        \r\n        while (this.bitsbuflen >= 8) {\r\n            this.bitsbuflen -= 8;\r\n            this.ip--;\r\n        }\r\n        this.op = op;\r\n    }\r\n    public decodeHuffmanAdaptive(litlen: Array<number>|Uint16Array, dist: Array<number>|Uint8Array) {\r\n        let output = this.output;\r\n        let op = this.op;\r\n      \r\n        this.currentLitlenTable = litlen;\r\n      \r\n        /** @type {number} output position limit. */\r\n        let olength = output.length;\r\n        /** @type {number} huffman code. */\r\n        let code;\r\n        /** @type {number} table index. */\r\n        let ti;\r\n        /** @type {number} huffman code distination. */\r\n        let codeDist;\r\n        /** @type {number} huffman code length. */\r\n        let codeLength;\r\n      \r\n        let lengthCodeTable = RawInflate.LengthCodeTable;\r\n        let lengthExtraTable = RawInflate.LengthExtraTable;\r\n        let distCodeTable = RawInflate.DistCodeTable;\r\n        let distExtraTable = RawInflate.DistExtraTable;\r\n    \r\n        code = this.readCodeByTable(litlen);\r\n        while (code !== 256) {\r\n          // literal\r\n          if (code < 256) {\r\n            if (op >= olength) {\r\n              output = this.expandBufferAdaptive();\r\n              olength = output.length;\r\n            }\r\n            output[op++] = code;\r\n      \r\n            continue;\r\n          }\r\n      \r\n          // length code\r\n          ti = code - 257;\r\n          codeLength = lengthCodeTable[ti];\r\n          if (lengthExtraTable[ti] > 0) {\r\n            codeLength += this.readBits(lengthExtraTable[ti]);\r\n          }\r\n      \r\n          // dist code\r\n          code = this.readCodeByTable(dist);\r\n          codeDist = distCodeTable[code];\r\n          if (distExtraTable[code] > 0) {\r\n            codeDist += this.readBits(distExtraTable[code]);\r\n          }\r\n      \r\n          // lz77 decode\r\n          if (op + codeLength > olength) {\r\n            output = this.expandBufferAdaptive();\r\n            olength = output.length;\r\n          }\r\n          while (codeLength--) {\r\n            output[op] = output[(op++) - codeDist];\r\n          }\r\n          code = this.readCodeByTable(litlen);\r\n        }\r\n      \r\n        while (this.bitsbuflen >= 8) {\r\n          this.bitsbuflen -= 8;\r\n          this.ip--;\r\n        }\r\n        this.op = op;\r\n    }\r\n    public expandBufferBlock(opt_param?: any) {\r\n        /** @type {!(Array.<number>|Uint8Array)} store buffer. */\r\n        let buffer =\r\n          new (USE_TYPEDARRAY ? Uint8Array : Array)(\r\n              this.op - RawInflate.MaxBackwardLength\r\n          );\r\n        /** @type {number} backward base point */\r\n        let backward = this.op - RawInflate.MaxBackwardLength;\r\n        /** @type {number} copy index. */\r\n        let i;\r\n        /** @type {number} copy limit */\r\n        let il;\r\n      \r\n        let output = this.output;\r\n      \r\n        // copy to output buffer\r\n        if (USE_TYPEDARRAY) {\r\n          (<Uint8Array>buffer).set((<Uint8Array>output).subarray(RawInflate.MaxBackwardLength, buffer.length));\r\n        } else {\r\n          for (i = 0, il = buffer.length; i < il; ++i) {\r\n            buffer[i] = output[i + RawInflate.MaxBackwardLength];\r\n          }\r\n        }\r\n      \r\n        this.blocks.push(buffer);\r\n        this.totalpos += buffer.length;\r\n      \r\n        // copy to backward buffer\r\n        if (USE_TYPEDARRAY) {\r\n          (<Uint8Array>output).set(\r\n            (<Uint8Array>output).subarray(backward, backward + RawInflate.MaxBackwardLength)\r\n          );\r\n        } else {\r\n          for (i = 0; i < RawInflate.MaxBackwardLength; ++i) {\r\n            output[i] = output[backward + i];\r\n          }\r\n        }\r\n      \r\n        this.op = RawInflate.MaxBackwardLength;\r\n      \r\n        return output;\r\n    }\r\n    public expandBufferAdaptive(opt_param?: any) {\r\n        /** @type {!(Array.<number>|Uint8Array)} store buffer. */\r\n        let buffer;\r\n        /** @type {number} expantion ratio. */\r\n        let ratio = (this.input.length / this.ip + 1) | 0;\r\n        /** @type {number} maximum number of huffman code. */\r\n        let maxHuffCode;\r\n        /** @type {number} new output buffer size. */\r\n        let newSize;\r\n        /** @type {number} max inflate size. */\r\n        let maxInflateSize;\r\n      \r\n        let input = this.input;\r\n        let output = this.output;\r\n      \r\n        if (opt_param) {\r\n          if (typeof opt_param.fixRatio === 'number') {\r\n            ratio = opt_param.fixRatio;\r\n          }\r\n          if (typeof opt_param.addRatio === 'number') {\r\n            ratio += opt_param.addRatio;\r\n          }\r\n        }\r\n      \r\n        // calculate new buffer size\r\n        if (ratio < 2) {\r\n          maxHuffCode =\r\n            (input.length - this.ip) / this.currentLitlenTable[2];\r\n          maxInflateSize = (maxHuffCode / 2 * 258) | 0;\r\n          newSize = maxInflateSize < output.length ?\r\n            output.length + maxInflateSize :\r\n            output.length << 1;\r\n        } else {\r\n          newSize = output.length * ratio;\r\n        }\r\n      \r\n        // buffer expantion\r\n        if (USE_TYPEDARRAY) {\r\n          buffer = new Uint8Array(newSize);\r\n          buffer.set(output);\r\n        } else {\r\n          buffer = output;\r\n        }\r\n      \r\n        this.output = buffer;\r\n      \r\n        return this.output;\r\n    }\r\n\r\n    public concatBufferBlock() {\r\n        /** @type {number} buffer pointer. */\r\n        let pos = 0;\r\n        /** @type {number} buffer pointer. */\r\n        let limit = this.totalpos + (this.op - RawInflate.MaxBackwardLength);\r\n        /** @type {!(Array.<number>|Uint8Array)} output block array. */\r\n        let output = this.output;\r\n        /** @type {!Array} blocks array. */\r\n        let blocks = this.blocks;\r\n        /** @type {!(Array.<number>|Uint8Array)} output block array. */\r\n        let block;\r\n        /** @type {!(Array.<number>|Uint8Array)} output buffer. */\r\n        let buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);\r\n        /** @type {number} loop counter. */\r\n        let i;\r\n        /** @type {number} loop limiter. */\r\n        let il;\r\n        /** @type {number} loop counter. */\r\n        let j;\r\n        /** @type {number} loop limiter. */\r\n        let jl;\r\n      \r\n        // single buffer\r\n        if (blocks.length === 0) {\r\n          return USE_TYPEDARRAY ?\r\n            (<Uint8Array>this.output).subarray(RawInflate.MaxBackwardLength, this.op) :\r\n            this.output.slice(RawInflate.MaxBackwardLength, this.op);\r\n        }\r\n      \r\n        // copy to buffer\r\n        for (i = 0, il = blocks.length; i < il; ++i) {\r\n          block = blocks[i];\r\n          for (j = 0, jl = block.length; j < jl; ++j) {\r\n            buffer[pos++] = block[j];\r\n          }\r\n        }\r\n      \r\n        // current buffer\r\n        for (i = RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {\r\n          buffer[pos++] = output[i];\r\n        }\r\n      \r\n        this.blocks = [];\r\n        this.buffer = buffer;\r\n      \r\n        return this.buffer;\r\n    }\r\n    public concatBufferDynamic() {\r\n        /** @type {Array.<number>|Uint8Array} output buffer. */\r\n        let buffer;\r\n        let op = this.op;\r\n      \r\n        if (USE_TYPEDARRAY) {\r\n          if (this.resize) {\r\n            buffer = new Uint8Array(op);\r\n            buffer.set((<Uint8Array>this.output).subarray(0, op));\r\n          } else {\r\n            buffer = (<Uint8Array>this.output).subarray(0, op);\r\n          }\r\n        } else {\r\n          if (this.output.length > op) {\r\n            this.output = this.output.slice(0,op-1);\r\n          }\r\n          buffer = this.output;\r\n        }\r\n      \r\n        this.buffer = buffer;\r\n      \r\n        return this.buffer;\r\n      };\r\n}\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\nimport { ZlibT } from './zlibt';\r\n\r\nconst ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE = 0x8000;\r\n\r\nenum rStatus {\r\n    INITIALIZED= 0,\r\n    BLOCK_HEADER_START= 1,\r\n    BLOCK_HEADER_END= 2,\r\n    BLOCK_BODY_START= 3,\r\n    BLOCK_BODY_END= 4,\r\n    DECODE_BLOCK_START= 5,\r\n    DECODE_BLOCK_END= 6\r\n};\r\n\r\nenum rBlockType {\r\n    UNCOMPRESSED= 0,\r\n    FIXED= 1,\r\n    DYNAMIC= 2,\r\n};\r\n\r\nconst buildHuffmanTable = ZlibT.Huffman.buildHuffmanTable;\r\n\r\nexport class RawInflateStream {\r\n\r\n    public static Status = rStatus;\r\n    public static BlockType= rBlockType;\r\n\r\n    public blocks : Array<(Array<number> | Uint8Array)>;\r\n    public bufferSize: number;\r\n    public totalpos: number;\r\n    public ip: number;\r\n    public bitsbuf: number;\r\n    public bitsbuflen: number;\r\n    public input: Array<number> | Uint8Array;\r\n    public output: Array<number> | Uint8Array;\r\n    public op: number;\r\n    public bfinal: boolean;\r\n    public blockLength: number;\r\n    public resize: boolean;\r\n    public litlenTable: Array<number>;\r\n    public distTable: Array<number>;\r\n    public sp: number;\r\n    public status=0;\r\n    public ip_;\r\n    public bitsbuflen_;\r\n    public bitsbuf_;\r\n    public currentBlockType;\r\n\r\n    public static MaxBackwardLength = 32768;\r\n\r\n    public static MaxCopyLength = 258;\r\n\r\n    public static Order = (()=>{\r\n        let table = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n    })();\r\n\r\n    public static LengthCodeTable = (() => {\r\n        const table = [\r\n            0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\r\n            0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\r\n            0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\r\n            0x00e3, 0x0102, 0x0102, 0x0102\r\n        ]\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n    })();\r\n    \r\n    public static LengthExtraTable = (() => {\r\n        const table = [\r\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\r\n            5, 5, 0, 0, 0\r\n        ]\r\n        return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n    })();\r\n\r\n    public static DistCodeTable = (() => {\r\n        let table = [\r\n            0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\r\n            0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\r\n            0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\r\n            0x3001, 0x4001, 0x6001\r\n        ]\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n    })();\r\n\r\n    public static DistExtraTable = (() => {\r\n        const table = [\r\n            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\r\n            11, 12, 12, 13, 13\r\n        ]\r\n        return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n    })();\r\n\r\n    public static FixedLiteralLengthTable = (() => {\r\n        let lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);\r\n        let i, il;\r\n        for (i = 0, il = lengths.length; i < il; ++i) {\r\n          lengths[i] =\r\n            (i <= 143) ? 8 :\r\n            (i <= 255) ? 9 :\r\n            (i <= 279) ? 7 :\r\n            8;\r\n        }\r\n        return buildHuffmanTable(lengths)\r\n    })();\r\n\r\n    public static FixedDistanceTable = (() => {\r\n        let lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);\r\n        let i, il;\r\n      \r\n        for (i = 0, il = lengths.length; i < il; ++i) {\r\n          lengths[i] = 5;\r\n        }\r\n      \r\n        return buildHuffmanTable(lengths);\r\n    })();\r\n\r\n    constructor (input: Uint8Array | Array<number>, ip?: number, opt_buffersize?: number) {\r\n         /** @type {!Array.<(Array|Uint8Array)>} */\r\n        this.blocks = [];\r\n        /** @type {number} block size. */\r\n        this.bufferSize =\r\n            opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE;\r\n        /** @type {!number} total output buffer pointer. */\r\n        this.totalpos = 0;\r\n        /** @type {!number} input buffer pointer. */\r\n        this.ip = ip === void 0 ? 0 : ip;\r\n        /** @type {!number} bit stream reader buffer. */\r\n        this.bitsbuf = 0;\r\n        /** @type {!number} bit stream reader buffer size. */\r\n        this.bitsbuflen = 0;\r\n        /** @type {!(Array|Uint8Array)} input buffer. */\r\n        this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;\r\n        /** @type {!(Uint8Array|Array)} output buffer. */\r\n        this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);\r\n        /** @type {!number} output buffer pointer. */\r\n        this.op = 0;\r\n        /** @type {boolean} is final block flag. */\r\n        this.bfinal = false;\r\n        /** @type {number} uncompressed block length. */\r\n        this.blockLength =0;\r\n        /** @type {boolean} resize flag for memory size optimization. */\r\n        this.resize = false;\r\n        /** @type {Array} */\r\n        this.litlenTable = [];\r\n        /** @type {Array} */\r\n        this.distTable = [];\r\n        /** @type {number} */\r\n        this.sp = 0; // stream pointer\r\n        /** @type {RawInflateStream.Status} */\r\n        this.status = RawInflateStream.Status.INITIALIZED;\r\n        /** @type {!number} */\r\n        this.ip_ = 0;\r\n        /** @type {!number} */\r\n        this.bitsbuflen_ = 0;\r\n        /** @type {!number} */\r\n        this.bitsbuf_ = 0;\r\n        this.currentBlockType = RawInflateStream.BlockType.FIXED;\r\n    }\r\n\r\n    public decompress(newInput: Uint8Array | Array<number>, ip: any) {\r\n        /** @type {boolean} */\r\n        let stop = false;\r\n      \r\n        if (newInput !== void 0) {\r\n          this.input = newInput;\r\n        }\r\n      \r\n        if (ip !== void 0) {\r\n          this.ip = ip;\r\n        }\r\n      \r\n        // decompress\r\n        while (!stop) {\r\n          switch (this.status) {\r\n            // block header\r\n            case RawInflateStream.Status.INITIALIZED:\r\n            case RawInflateStream.Status.BLOCK_HEADER_START:\r\n              if (this.readBlockHeader() < 0) {\r\n                stop = true;\r\n              }\r\n              break;\r\n            // block body\r\n            case RawInflateStream.Status.BLOCK_HEADER_END: /* FALLTHROUGH */\r\n            case RawInflateStream.Status.BLOCK_BODY_START:\r\n              switch(this.currentBlockType) {\r\n                case RawInflateStream.BlockType.UNCOMPRESSED:\r\n                  if (this.readUncompressedBlockHeader() < 0) {\r\n                    stop = true;\r\n                  }\r\n                  break;\r\n                case RawInflateStream.BlockType.FIXED:\r\n                  if (this.parseFixedHuffmanBlock() < 0) {\r\n                    stop = true;\r\n                  }\r\n                  break;\r\n                case RawInflateStream.BlockType.DYNAMIC:\r\n                  if (this.parseDynamicHuffmanBlock() < 0) {\r\n                    stop = true;\r\n                  }\r\n                  break;\r\n                default:\r\n                  break;\r\n              }\r\n              break;\r\n            // decode data\r\n            case RawInflateStream.Status.BLOCK_BODY_END:\r\n            case RawInflateStream.Status.DECODE_BLOCK_START:\r\n                switch(this.currentBlockType) {\r\n                    case RawInflateStream.BlockType.UNCOMPRESSED:\r\n                        if (this.parseUncompressedBlock() < 0) {\r\n                            stop = true;\r\n                        }\r\n                    break;\r\n                    case RawInflateStream.BlockType.FIXED: /* FALLTHROUGH */\r\n                    case RawInflateStream.BlockType.DYNAMIC:\r\n                        if (this.decodeHuffman() < 0) {\r\n                            stop = true;\r\n                        }\r\n                    break;\r\n                    default:\r\n                        break;\r\n            }\r\n              break;\r\n            case RawInflateStream.Status.DECODE_BLOCK_END:\r\n              if (this.bfinal) {\r\n                stop = true;\r\n              } else {\r\n                this.status = RawInflateStream.Status.INITIALIZED;\r\n              }\r\n              break;\r\n            default:\r\n              break;\r\n            }\r\n        }\r\n        return this.concatBuffer();\r\n    }\r\n\r\n    public readBlockHeader() {\r\n        /** @type {number} header */\r\n        let hdr;\r\n      \r\n        this.status = RawInflateStream.Status.BLOCK_HEADER_START;\r\n      \r\n        this.save_();\r\n        hdr = this.readBits(3)\r\n        if (hdr < 0) {\r\n          this.restore_();\r\n          return -1;\r\n        }\r\n      \r\n        // BFINAL\r\n        if (hdr & 0x1) {\r\n          this.bfinal = true;\r\n        }\r\n      \r\n        // BTYPE\r\n        hdr >>>= 1;\r\n        switch (hdr) {\r\n          case 0: // uncompressed\r\n            this.currentBlockType = RawInflateStream.BlockType.UNCOMPRESSED;\r\n            break;\r\n          case 1: // fixed huffman\r\n            this.currentBlockType = RawInflateStream.BlockType.FIXED;\r\n            break;\r\n          case 2: // dynamic huffman\r\n            this.currentBlockType = RawInflateStream.BlockType.DYNAMIC;\r\n            break;\r\n          default: // reserved or other\r\n            throw new Error('unknown BTYPE: ' + hdr);\r\n        }\r\n      \r\n        this.status = RawInflateStream.Status.BLOCK_HEADER_END;\r\n    }\r\n\r\n    public readBits(length: number) {\r\n        let bitsbuf = this.bitsbuf;\r\n        let bitsbuflen = this.bitsbuflen;\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n      \r\n        /** @type {number} input and output byte. */\r\n        let octet;\r\n      \r\n        // not enough buffer\r\n        while (bitsbuflen < length) {\r\n          // input byte\r\n          if (input.length <= ip) {\r\n            return -1;\r\n          }\r\n          octet = input[ip++];\r\n      \r\n          // concat octet\r\n          bitsbuf |= octet << bitsbuflen;\r\n          bitsbuflen += 8;\r\n        }\r\n      \r\n        // output byte\r\n        octet = bitsbuf & /* MASK */ ((1 << length) - 1);\r\n        bitsbuf >>>= length;\r\n        bitsbuflen -= length;\r\n      \r\n        this.bitsbuf = bitsbuf;\r\n        this.bitsbuflen = bitsbuflen;\r\n        this.ip = ip;\r\n      \r\n        return octet;\r\n    }\r\n\r\n    public readCodeByTable(table: Array<number> | Uint8Array) {\r\n        let bitsbuf = this.bitsbuf;\r\n        let bitsbuflen = this.bitsbuflen;\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n      \r\n        /** @type {!(Array|Uint8Array)} huffman code table */\r\n        let codeTable = table[0];\r\n        /** @type {number} */\r\n        let maxCodeLength = table[1];\r\n        /** @type {number} input byte */\r\n        let octet;\r\n        /** @type {number} code length & code (16bit, 16bit) */\r\n        let codeWithLength;\r\n        /** @type {number} code bits length */\r\n        let codeLength;\r\n      \r\n        // not enough buffer\r\n        while (bitsbuflen < maxCodeLength) {\r\n          if (input.length <= ip) {\r\n            return -1;\r\n          }\r\n          octet = input[ip++];\r\n          bitsbuf |= octet << bitsbuflen;\r\n          bitsbuflen += 8;\r\n        }\r\n      \r\n        // read max length\r\n        codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\r\n        codeLength = codeWithLength >>> 16;\r\n      \r\n        if (codeLength > bitsbuflen) {\r\n          throw new Error('invalid code length: ' + codeLength);\r\n        }\r\n      \r\n        this.bitsbuf = bitsbuf >> codeLength;\r\n        this.bitsbuflen = bitsbuflen - codeLength;\r\n        this.ip = ip;\r\n      \r\n        return codeWithLength & 0xffff;\r\n    }\r\n    public readUncompressedBlockHeader() {\r\n        /** @type {number} block length */\r\n        let len;\r\n        /** @type {number} number for check block length */\r\n        let nlen;\r\n      \r\n        let input = this.input;\r\n        let ip = this.ip;\r\n      \r\n        this.status = RawInflateStream.Status.BLOCK_BODY_START;\r\n      \r\n        if (ip + 4 >= input.length) {\r\n          return -1;\r\n        }\r\n      \r\n        len = input[ip++] | (input[ip++] << 8);\r\n        nlen = input[ip++] | (input[ip++] << 8);\r\n      \r\n        // check len & nlen\r\n        if (len === ~nlen) {\r\n          throw new Error('invalid uncompressed block header: length verify');\r\n        }\r\n      \r\n        // skip buffered header bits\r\n        this.bitsbuf = 0;\r\n        this.bitsbuflen = 0;\r\n      \r\n        this.ip = ip;\r\n        this.blockLength = len;\r\n        this.status = RawInflateStream.Status.BLOCK_BODY_END;\r\n    }\r\n\r\n    public parseUncompressedBlock() {\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n        let output = this.output;\r\n        let op = this.op;\r\n        let len = this.blockLength;\r\n      \r\n        this.status = RawInflateStream.Status.DECODE_BLOCK_START;\r\n      \r\n        // copy\r\n        // XXX: \r\n        while (len--) {\r\n          if (op === output.length) {\r\n            output = this.expandBuffer({fixRatio: 2});\r\n          }\r\n      \r\n          // not enough input buffer\r\n          if (ip >= input.length) {\r\n            this.ip = ip;\r\n            this.op = op;\r\n            this.blockLength = len + 1; // \r\n            return -1;\r\n          }\r\n      \r\n          output[op++] = input[ip++];\r\n        }\r\n      \r\n        if (len < 0) {\r\n          this.status = RawInflateStream.Status.DECODE_BLOCK_END;\r\n        }\r\n      \r\n        this.ip = ip;\r\n        this.op = op;\r\n      \r\n        return 0;\r\n    }\r\n\r\n    public parseFixedHuffmanBlock() {\r\n        this.status = RawInflateStream.Status.BLOCK_BODY_START;\r\n      \r\n        this.litlenTable = RawInflateStream.FixedLiteralLengthTable;\r\n        this.distTable = RawInflateStream.FixedDistanceTable;\r\n      \r\n        this.status = RawInflateStream.Status.BLOCK_BODY_END;\r\n      \r\n        return 0;\r\n    }\r\n\r\n    public save_() {\r\n        this.ip_ = this.ip;\r\n        this.bitsbuflen_ = this.bitsbuflen;\r\n        this.bitsbuf_ = this.bitsbuf;\r\n    }\r\n\r\n    public restore_() {\r\n        this.ip = this.ip_;\r\n        this.bitsbuflen = this.bitsbuflen_;\r\n        this.bitsbuf = this.bitsbuf_;\r\n    }\r\n\r\n    public parseDynamicHuffmanBlock() {\r\n        /** @type {number} number of literal and length codes. */\r\n        let hlit;\r\n        /** @type {number} number of distance codes. */\r\n        let hdist;\r\n        /** @type {number} number of code lengths. */\r\n        let hclen;\r\n        /** @type {!(Uint8Array|Array)} code lengths. */\r\n        let codeLengths =\r\n          new (USE_TYPEDARRAY ? Uint8Array : Array)(RawInflateStream.Order.length);\r\n        /** @type {!Array} code lengths table. */\r\n        let codeLengthsTable;\r\n        /** @type {!(Uint32Array|Array)} literal and length code lengths. */\r\n        let litlenLengths;\r\n        /** @type {!(Uint32Array|Array)} distance code lengths. */\r\n        let distLengths;\r\n      \r\n        this.status = RawInflateStream.Status.BLOCK_BODY_START;\r\n      \r\n        this.save_();\r\n        hlit = this.readBits(5) + 257;\r\n        hdist = this.readBits(5) + 1;\r\n        hclen = this.readBits(4) + 4;\r\n        if (hlit < 0 || hdist < 0 || hclen < 0) {\r\n          this.restore_();\r\n          return -1;\r\n        }\r\n        const parseDynamicHuffmanBlockImpl = () => {\r\n          /** @type {number} */\r\n          let bits;\r\n          let code;\r\n          let prev = 0;\r\n          let repeat;\r\n          /** @type {!(Uint8Array|Array.<number>)} code length table. */\r\n          let lengthTable;\r\n          /** @type {number} loop counter. */\r\n          let i;\r\n          /** @type {number} loop limit. */\r\n          let il;\r\n      \r\n          // decode code lengths\r\n          for (i = 0; i < hclen; ++i) {\r\n            bits = this.readBits(3);\r\n            if ((bits) < 0) {\r\n              throw new Error('not enough input');\r\n            }\r\n            codeLengths[RawInflateStream.Order[i]] = bits;\r\n          }\r\n      \r\n          // decode length table\r\n          codeLengthsTable = buildHuffmanTable(codeLengths);\r\n          lengthTable = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit + hdist);\r\n          for (i = 0, il = hlit + hdist; i < il;) {\r\n            code = this.readCodeByTable(codeLengthsTable);\r\n            if (code < 0) {\r\n              throw new Error('not enough input');\r\n            }\r\n            switch (code) {\r\n              case 16:\r\n                bits = this.readBits(2);\r\n                if (bits < 0) {\r\n                  throw new Error('not enough input');\r\n                }\r\n                repeat = 3 + bits;\r\n                while (repeat--) { lengthTable[i++] = prev; }\r\n                break;\r\n              case 17:\r\n                bits = this.readBits(3)\r\n                if (bits < 0) {\r\n                  throw new Error('not enough input');\r\n                }\r\n                repeat = 3 + bits;\r\n                while (repeat--) { lengthTable[i++] = 0; }\r\n                prev = 0;\r\n                break;\r\n              case 18:\r\n                bits = this.readBits(7)\r\n                if (bits < 0) {\r\n                  throw new Error('not enough input');\r\n                }\r\n                repeat = 11 + bits;\r\n                while (repeat--) { lengthTable[i++] = 0; }\r\n                prev = 0;\r\n                break;\r\n              default:\r\n                lengthTable[i++] = code;\r\n                prev = code;\r\n                break;\r\n            }\r\n          }\r\n      \r\n          // literal and length code\r\n          litlenLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit);\r\n      \r\n          // distance code\r\n          distLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hdist);\r\n      \r\n          this.litlenTable = USE_TYPEDARRAY\r\n            ? buildHuffmanTable(lengthTable.subarray(0, hlit))\r\n            : buildHuffmanTable(lengthTable.slice(0, hlit));\r\n          this.distTable = USE_TYPEDARRAY\r\n            ? buildHuffmanTable(lengthTable.subarray(hlit))\r\n            : buildHuffmanTable(lengthTable.slice(hlit));\r\n        }\r\n        try {\r\n            parseDynamicHuffmanBlockImpl();\r\n          } catch(e) {\r\n            this.restore_();\r\n            return -1;\r\n        }\r\n        this.status = RawInflateStream.Status.BLOCK_BODY_END;\r\n        return 0;\r\n    }\r\n\r\n    public decodeHuffman() {\r\n        let output = this.output;\r\n        let op = this.op;\r\n      \r\n        /** @type {number} huffman code. */\r\n        let code;\r\n        /** @type {number} table index. */\r\n        let ti;\r\n        /** @type {number} huffman code distination. */\r\n        let codeDist;\r\n        /** @type {number} huffman code length. */\r\n        let codeLength;\r\n      \r\n        let litlen = this.litlenTable;\r\n        let dist = this.distTable;\r\n      \r\n        let olength = output.length;\r\n        let bits;\r\n      \r\n        this.status = RawInflateStream.Status.DECODE_BLOCK_START;\r\n      \r\n        while (true) {\r\n          this.save_();\r\n      \r\n          code = this.readCodeByTable(litlen);\r\n          if (code < 0) {\r\n            this.op = op;\r\n            this.restore_();\r\n            return -1;\r\n          }\r\n      \r\n          if (code === 256) {\r\n            break;\r\n          }\r\n      \r\n          // literal\r\n          if (code < 256) {\r\n            if (op === olength) {\r\n              output = this.expandBuffer();\r\n              olength = output.length;\r\n            }\r\n            output[op++] = code;\r\n      \r\n            continue;\r\n          }\r\n      \r\n          // length code\r\n          ti = code - 257;\r\n          codeLength = RawInflateStream.LengthCodeTable[ti];\r\n          if (RawInflateStream.LengthExtraTable[ti] > 0) {\r\n            bits = this.readBits(RawInflateStream.LengthExtraTable[ti]);\r\n            if (bits < 0) {\r\n              this.op = op;\r\n              this.restore_();\r\n              return -1;\r\n            }\r\n            codeLength += bits;\r\n          }\r\n      \r\n          // dist code\r\n          code = this.readCodeByTable(dist);\r\n          if (code < 0) {\r\n            this.op = op;\r\n            this.restore_();\r\n            return -1;\r\n          }\r\n          codeDist = RawInflateStream.DistCodeTable[code];\r\n          if (RawInflateStream.DistExtraTable[code] > 0) {\r\n            bits = this.readBits(RawInflateStream.DistExtraTable[code]);\r\n            if (bits < 0) {\r\n              this.op = op;\r\n              this.restore_();\r\n              return -1;\r\n            }\r\n            codeDist += bits;\r\n          }\r\n      \r\n          // lz77 decode\r\n          if (op + codeLength >= olength) {\r\n            output = this.expandBuffer();\r\n            olength = output.length;\r\n          }\r\n      \r\n          while (codeLength--) {\r\n            output[op] = output[(op++) - codeDist];\r\n          }\r\n      \r\n          // break\r\n          if (this.ip === this.input.length) {\r\n            this.op = op;\r\n            return -1;\r\n          }\r\n        }\r\n      \r\n        while (this.bitsbuflen >= 8) {\r\n          this.bitsbuflen -= 8;\r\n          this.ip--;\r\n        }\r\n      \r\n        this.op = op;\r\n        this.status = RawInflateStream.Status.DECODE_BLOCK_END;\r\n    }\r\n\r\n    public expandBuffer(opt_param?: any) {\r\n        /** @type {!(Array|Uint8Array)} store buffer. */\r\n        let buffer;\r\n        /** @type {number} expantion ratio. */\r\n        let ratio = (this.input.length / this.ip + 1) | 0;\r\n        /** @type {number} maximum number of huffman code. */\r\n        let maxHuffCode;\r\n        /** @type {number} new output buffer size. */\r\n        let newSize;\r\n        /** @type {number} max inflate size. */\r\n        let maxInflateSize;\r\n      \r\n        let input = this.input;\r\n        let output = this.output;\r\n      \r\n        if (opt_param) {\r\n          if (typeof opt_param.fixRatio === 'number') {\r\n            ratio = opt_param.fixRatio;\r\n          }\r\n          if (typeof opt_param.addRatio === 'number') {\r\n            ratio += opt_param.addRatio;\r\n          }\r\n        }\r\n      \r\n        // calculate new buffer size\r\n        if (ratio < 2) {\r\n          maxHuffCode =\r\n            (input.length - this.ip) / this.litlenTable[2];\r\n          maxInflateSize = (maxHuffCode / 2 * 258) | 0;\r\n          newSize = maxInflateSize < output.length ?\r\n            output.length + maxInflateSize :\r\n            output.length << 1;\r\n        } else {\r\n          newSize = output.length * ratio;\r\n        }\r\n      \r\n        // buffer expantion\r\n        if (USE_TYPEDARRAY) {\r\n          buffer = new Uint8Array(newSize);\r\n          buffer.set(output);\r\n        } else {\r\n          buffer = output;\r\n        }\r\n      \r\n        this.output = buffer;\r\n      \r\n        return this.output;\r\n      };\r\n      \r\n      public concatBuffer() {\r\n        /** @type {!(Array|Uint8Array)} output buffer. */\r\n        let buffer;\r\n        /** @type {number} */\r\n        let op = this.op;\r\n        /** @type {Uint8Array} */\r\n        let tmp;\r\n      \r\n        if (this.resize) {\r\n          if (USE_TYPEDARRAY) {\r\n            buffer = new Uint8Array((<Uint8Array>this.output).subarray(this.sp, op));\r\n          } else {\r\n            buffer = this.output.slice(this.sp, op);\r\n          }\r\n        } else {\r\n          buffer =\r\n            USE_TYPEDARRAY ? (<Uint8Array>this.output).subarray(this.sp, op) : this.output.slice(this.sp, op);\r\n        }\r\n      \r\n        this.sp = op;\r\n      \r\n        // compaction\r\n        if (op > RawInflateStream.MaxBackwardLength + this.bufferSize) {\r\n          this.op = this.sp = RawInflateStream.MaxBackwardLength;\r\n          if (USE_TYPEDARRAY) {\r\n            tmp = /** @type {Uint8Array} */(this.output);\r\n            this.output = new Uint8Array(this.bufferSize + RawInflateStream.MaxBackwardLength);\r\n            this.output.set(tmp.subarray(op - RawInflateStream.MaxBackwardLength, op));\r\n          } else {\r\n            this.output = this.output.slice(op - RawInflateStream.MaxBackwardLength);\r\n          }\r\n        }\r\n        return buffer;\r\n      }\r\n}\r\n","import { Adler32 as rAdler32, Alder as rAdler} from './adler32';\r\nimport { RawDeflate as rRawDeflate} from './rawdeflate';\r\nimport { CRC32 as rCRC32 } from './crc32';\r\nimport { Heap as rHeap } from './heap';\r\nimport { Huffman as rHuffman } from './huffman';\r\nimport { Zip as rZip } from './zip';\r\nimport { RawInflate as rRawInflate } from './rawinflate';\r\nimport { RawInflateStream as rRawInflateStream } from './rawinflate_stream';\r\n\r\nexport namespace ZlibT {\r\n    export const Adler32 = rAdler32;\r\n    export class Alder extends rAdler {};\r\n    export class RawDeflate extends rRawDeflate {};\r\n    export class CRC32 extends rCRC32 {};\r\n    export class Heap extends rHeap{};\r\n    export class RawInflateStream extends rRawInflateStream{};\r\n    export const CompressionMethod = {\r\n        DEFLATE: 8,\r\n        RESERVED: 15\r\n    };\r\n    export class Zip extends rZip {};\r\n    export class RawInflate extends rRawInflate {};\r\n    \r\n    export class Huffman extends rHuffman{}; \r\n}\r\n"],"sourceRoot":""}